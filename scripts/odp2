"""
This script performs mutual-best protein diamond BLAST searches,
 then makes synteny plots of those results.

Author: Darrin Schultz
Email : dts@ucsc.edu

"""

from Bio import SeqIO
#from itertools import groupby
#from itertools import product
from itertools import permutations
from itertools import combinations
import logging
#import matplotlib
from matplotlib.patches import Patch
from matplotlib.lines   import Line2D
from matplotlib.font_manager import FontProperties

#from matplotlib.lines import Line2D
#import math
import networkx as nx
import numpy as np
#from operator import itemgetter
import odp_functions as odpf
import odp_color_manager as oc
import pandas as pd
import scipy.stats as stats
#import statistics
#import sys

configfile: "config.yaml"

# check for legal config entries. Useful for finding misspelled entries
legal = ["proteins", "chrom", "genome", "minscafsize",
         "manual_breaks", "plotorder", "sort_by_x_coord_blast",
         "noylines", "noxlines", "genus", "species"]

config["tool"] = "odp"

# check diamond_or_blastp
if "diamond_or_blastp" not in config:
    config["diamond_or_blastp"] = "blastp"
else:
    if config["diamond_or_blastp"] not in ["diamond", "blastp"]:
        raise IOError("diamond_or_blastp must be either 'diamond' or 'blastp'")

# check if species in the snakefile
if "species" not in config:
    raise IOError("You must have a 'species' fields in the config file.")

# make sure none of the sample names have underscores
for thissample in config["species"]:
    if "_" in thissample:
        raise IOError("Sample names can't have '_' char: {}".format(thissample))

# make sure there are at least 2 samples
if len(config["species"]) < 2:
    raise IOError("There must be at least 2 samples")

# see if we have included any illegal arguments
illegal = set()
for this_sample in config["species"]:
    for key in config["species"][this_sample]:
        if key not in legal:
            illegal.add(key)

if len(illegal) > 0:
    print("We found some fields in your config file that are not used by this program.")
    print("The only fields allowed for individual samples are:")
    for key in legal:
        print("  - {}".format(key))
    print("The keys that we found that are not allowed/in the list above are:")
    for key in illegal:
        print("  - {}".format(key))

# check diamond_or_blastp
if "diamond_or_blastp" not in config:
    config["diamond_or_blastp"] = "blastp"
else:
    if config["diamond_or_blastp"] not in ["diamond", "blastp"]:
        raise IOError("diamond_or_blastp must be either 'diamond' or 'blastp'")

#make fake breaks for later analyses
for this in config["species"]:
    if "manual_breaks" not in config["species"][this]:
        config["species"][this]["manual_breaks"] = []
    if "minscafsize" not in config["species"][this]:
        config["species"][this]["minscafsize"] = 5000

def flatten(list_of_lists):
    """flatten a list of lists, unique only"""
    return list(set([item for sublist in list_of_lists for item in sublist]))

autobreak_files = []
make_autobreaks = True
if "ignore_autobreaks" in config:
    if config["ignore_autobreaks"]:
        make_autobreaks = False
    else:
        pass
else:
    pass


ignore_Fisher = False
if "ignore_Fisher" in config:
    if config["ignore_Fisher"]:
        ignore_Fisher = True
    else:
        pass
else:
    pass

# check if prot_to_color in config
if "prot_to_color" not in config:
    config["prot_to_color"] = {}

# add the prot_to_color entries from the install directory
filepath = os.path.dirname(os.path.realpath(workflow.snakefile))
colors_path=os.path.join(filepath, "../LG_db/")
color_directories = [ os.path.abspath(f.path) for f in os.scandir(colors_path) if f.is_dir() ]
for thisdir in color_directories:
    trim = os.path.split(thisdir)[1]
    config["prot_to_color"][trim] = thisdir

# come up with a list of blast/diamond jobs
# we must have every combination that is in the analyses_list
config["blastjobs"] = {}
config["analysisspecies"] = set()
config["analysispairs"] = {}
for tup in list(permutations(config["species"], 2)):
    # all the blast analyses
    config["blastjobs"]["{}_{}".format(tup[0], tup[1])] = list(tup)
    # the individual species
    config["analysisspecies"].add(tup[0])
    config["analysisspecies"].add(tup[1])
    # get the sorted reciprocal analyses
    t = list(sorted(tup))
    config["analysispairs"]["{}_{}".format(t[0], t[1])] = t

wildcard_constraints:
    sample1="[A-Za-z0-9]+",
    sample2="[A-Za-z0-9]+",
    #datatype="[A-Za-z0-9]+",
    #kmer="[A-Za-z0-9]+",
    #nom="[A-Za-z0-9.]+",
    #telo="[A-Za-z0-9]+",
    #binsize="[0-9]+",
    #qval="[0-9]+",
    #telodir="[fr]"

rule all:
    input:
        #blast_jobs
        # find the reciprocal best hits
        [config["tool"] + "/step1-rbh/{}_reciprocal_best_hits.rbh".format(x)
         for x in config["analysispairs"]],
        # no color here
        [config["tool"] + "/step2-figures/synteny_nocolor/{}_xy_reciprocal_best_hits.plotted.rbh".format(x)
         for x in config["analysispairs"]],
        [config["tool"] + "/step2-figures/synteny_nocolor/{}_xy_synteny.pdf".format(x)
         for x in config["analysispairs"]],
        [config["tool"] + "/step2-figures/synteny_nocolor/{}_yx_synteny.pdf".format(x)
         for x in config["analysispairs"]],

        [config["tool"] + "/step0-blastp_results/{}_against_{}.hmmsearch.filt.blastp".format(hmm, sp)
         for sp in config["analysisspecies"] for hmm in config["prot_to_color"]],
        # color by the things in the prot_to_loc settings
        [config["tool"] + "/step2-figures/synteny_coloredby_{}/{}_xy_reciprocal_best_hits.coloredby_{}.plotted.rbh".format(y, x, y)
         for x in config["analysispairs"] for y in config["prot_to_color"]],
        [config["tool"] + "/step2-figures/synteny_coloredby_{}/{}_xy_synteny_coloredby_{}.pdf".format(y, x, y)
         for x in config["analysispairs"] for y in config["prot_to_color"]],
        [config["tool"] + "/step2-figures/synteny_coloredby_{}/{}_yx_synteny_coloredby_{}.pdf".format(y, x, y)
         for x in config["analysispairs"] for y in config["prot_to_color"]]

def filter_fasta_chrom(chrom_file, input_fasta, output_fasta):
    """
    takes a chrom file, only keeps proteins in input_fasta from chrom file,
     saves those prots to output_fasta
    """
    keep_these = set()
    printed_already = set()
    with open(chrom_file, "r") as f:
        for line in f:
            line = line.strip()
            if line:
                splitd = line.split()
                keep_these.add(splitd[0])
    outhandle = open(output_fasta, "w")
    inhandle =  open(input_fasta, "r")
    for record in SeqIO.parse(inhandle, "fasta"):
        if record.id in keep_these and record.id not in printed_already:
            SeqIO.write(record, outhandle, "fasta")
            printed_already.add(record.id)
    inhandle.close()
    outhandle.close()

rule filter_prots:
    """
    Sometimes the prot file with have sequences that are not present in
     the chrom file. Make a prot file of only the proteins in the chrom file.
    """
    input:
        prots = lambda wildcards: config["species"][wildcards.sample]["proteins"],
        chrom = lambda wildcards: config["species"][wildcards.sample]["chrom"]
    output:
        pep = config["tool"] + "/db/{sample}_prots.pep"
    threads: 1
    run:
        filter_fasta_chrom(input.chrom, input.prots, output.pep)

rule make_diamond_and_blast_db:
    input:
        pep = ancient(config["tool"] + "/db/{sample}_prots.pep")
    output:
        dmnd = config["tool"] + "/db/dmnd/{sample}_prots.dmnd",
        phr  = config["tool"] + "/db/{sample}_prots.pep.phr",
        pin  = config["tool"] + "/db/{sample}_prots.pep.pin",
        psq  = config["tool"] + "/db/{sample}_prots.pep.psq"
    params:
        outdir = config["tool"] + "/db/dmnd"
    threads: workflow.cores - 1
    shell:
        """
        mkdir -p {params.outdir}
        diamond makedb --in {input.pep} --db {output.dmnd}
        makeblastdb -in {input.pep} -dbtype prot
        """

rule diamond_blast:
    input:
        pep1  = ancient(config["tool"] + "/db/{sample1}_prots.pep"),
        dmnd1 = ancient(config["tool"] + "/db/dmnd/{sample1}_prots.dmnd"),
        pep2  = ancient(config["tool"] + "/db/{sample2}_prots.pep"),
        phr   = ancient(config["tool"] + "/db/{sample2}_prots.pep.phr"),
        pin   = ancient(config["tool"] + "/db/{sample2}_prots.pep.pin"),
        psq   = ancient(config["tool"] + "/db/{sample2}_prots.pep.psq"),
        dmnd2 = ancient(config["tool"] + "/db/dmnd/{sample2}_prots.dmnd")
    output:
        blastp = config["tool"] + "/step0-blastp_results/{sample1}_against_{sample2}.blastp"
    threads: (workflow.cores - 1)
    params:
        search_method = config["diamond_or_blastp"]
    priority: 1
    shell:
        """
        if [ "{params.search_method}" = "blastp" ]; then
            blastp -query {input.pep1} -db {input.pep2} \
              -num_threads {threads} -evalue 1E-5 -outfmt 6 > {output.blastp}
        elif [ "{params.search_method}" = "diamond" ]; then
            diamond blastp --query {input.pep1} --db {input.dmnd2} \
              --threads {threads} --evalue 1E-5 --outfmt 6 --out {output.blastp}
        fi
        """

rule reciprocal_best_hits:
    """
    finds the reciprocal best hits.
    reports it in the form of the blastp results from x -> y search
    """
    input:
        blastp1to2 = config["tool"] + "/step0-blastp_results/{sample1}_against_{sample2}.blastp",
        blastp2to1 = config["tool"] + "/step0-blastp_results/{sample2}_against_{sample1}.blastp"
    output:
        blastp1to2 = config["tool"] + "/step0-blastp_results/reciprocal_best/{sample1}_and_{sample2}_recip.temp.blastp",
        blastp2to1 = config["tool"] + "/step0-blastp_results/reciprocal_best/{sample2}_and_{sample1}_recip.temp.blastp",
    threads: 1
    run:
        odpf.reciprocal_best_hits_blastp_or_diamond_blastp(
            input.blastp1to2, input.blastp2to1, output.blastp1to2)
        df = pd.read_csv(output.blastp1to2, sep = "\t", header = None)
        newdf = df[[1,0,2,3,4,5,8,9,6,7,10,11]]
        newdf.to_csv(output.blastp2to1, sep ="\t", header = None, index = None)

def get_component_size_dict(G):
    """
    Prints out a dictionary of the component sizes of the graph.
    G is the graph.

    keys are the sizes of the components.
    values are the number of components of that size
    """
    component_size = {}
    for thisentry in list(nx.connected_components(G)):
        if len(thisentry) not in component_size:
            component_size[len(thisentry)] = 0
        component_size[len(thisentry)] += 1
    print(component_size)

def species_to_chrom_to_size(conf):
    """
    lazy method to generate a dict of dicts:
    {Species: {chrom1: size, chrom2: size}}
    just uses the config file
    """
    s2c2s = {}
    for thisspecies in conf["species"]:
        s2c2s[thisspecies] = {}
        for record in SeqIO.parse(conf["species"][thisspecies]["genome"], "fasta"):
            clen = len(record.seq)
            if clen >= int(conf["species"][thisspecies]["minscafsize"]):
                s2c2s[thisspecies][record.id] = len(record.seq)
    return s2c2s

rule n_ways_reciprocal_best:
    """
    Gets reciprocal best hits from 3 or more samples
    For a protein to be retained, it must be a reciprocal-best hit in three samples.

              A      B
             / \    /|\
            B___C  A-+-C , et cetera
                    \|/
                     D

    The output of this rule is a yaml file with admissible proteins from each sample
    """
    input:
        xtoyblastp = [config["tool"] + "/step0-blastp_results/reciprocal_best/{}_recip.temp.blastp".format(
            "_and_".join(config["analysispairs"][this])) for this in config["analysispairs"]],
        chrom = lambda wildcards: [config["species"][x]["chrom"]
                    for x in config["analysisspecies"]]
    output:
        acceptable_prots = config["tool"] + "/step0-blastp_results/reciprocal_best/{analysis}_acceptable_prots.txt",
        blast_network    = config["tool"] + "/step0-blastp_results/reciprocal_best/{analysis}_edges.txt",
        rbh              = config["tool"] + "/step1-rbh/{analysis}_reciprocal_best_hits.rbh"
    threads: 1
    run:
        # prot to group
        # January 9 2023 - I think this block of code is no longer relevant
        prot_to_group = {}
        if "prot_to_group" in config:
            if os.path.exists(config["prot_to_group"]):
                with open(config["prot_to_group"], "r") as f:
                    for line in f:
                        line = line.strip()
                        fields = line.split("\t")
                        prot_to_group[fields[0]] = fields[1]

        #print(prot_to_group)
        species_string = output.acceptable_prots.split("/")[-1].replace("_acceptable_prots.txt", "")
        all_species = species_string.split("_")
        combos = list(combinations(all_species, 2))
        blastfiles = [[config["tool"] + "/step0-blastp_results/reciprocal_best/{}_and_{}_recip.temp.blastp".format(x[0], x[1]),
             x[0], x[1]] for x in combos]
        gene_to_species = {}
        gene_list = set()

        # get the chrom files
        chrom_dicts = {}
        for thisspecies in all_species:
            if not os.path.exists(config["species"][thisspecies]["chrom"]):
                raise IOError("This chrom file doesn't exist: {}".format(
                    config["species"][thisspecies]["chrom"]))
            chrom_dicts[thisspecies] = pd.read_csv(
                config["species"][thisspecies]["chrom"],
                header=None, sep = "\t")
            chrom_dicts[thisspecies].columns = ["prot",
                "scaf", "direction", "start", "stop"]
            # we must convert the prot ID to type string in case the protein IDs are just numbers
            chrom_dicts[thisspecies]["prot"] = chrom_dicts[thisspecies]["prot"].astype(str)

        # initialize the graph
        G = nx.Graph()
        checked_names = set()
        for analysis in blastfiles:
            thisfile = analysis[0]
            print(thisfile)
            a = analysis[1]
            b = analysis[2]
            with open(thisfile, "r") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        splitb = line.split("\t")
                        agene = "{}_{}".format(a, splitb[0])
                        bgene = "{}_{}".format(b, splitb[1])
                        evalue = float(splitb[-2])
                        bitscore = float(splitb[-1])
                        if a not in checked_names:
                            if agene in gene_list:
                                raise IOError("""We saw a gene twice. {}.
                                This means that two species have the same prot ids.""".format(agene))
                        gene_list.add(agene)
                        if b not in checked_names:
                            if bgene in gene_list:
                                raise IOError("""We saw a gene twice. {}.
                                This means that two species have the same prot ids.""".format(bgene))
                        gene_list.add(bgene)
                        gene_to_species[agene] = a
                        gene_to_species[bgene] = b
                        #add these since we've added the genes already
                        checked_names.add(a)
                        checked_names.add(b)
                        # now add the edge
                        G.add_edge(agene, bgene, weight = bitscore)
        remnodes = set()
        #get rid of things that couldn't possibly be an n-way best
        for thisentry in list(nx.connected_components(G)):
            if len(thisentry) < len(all_species):
                for node in thisentry:
                    remnodes.add(node)
        for node in remnodes:
            G.remove_node(node)
        remnodes.clear()

        # now get rid of nodes that don't have the correct degree
        #  to be n-connected
        for thisnode in G.nodes:
            if G.degree[thisnode] != (len(all_species) - 1):
                remnodes.add(thisnode)
        for node in remnodes:
            G.remove_node(node)
        remnodes.clear()
        # now get the n-connected components
        nwaybest = []
        for thisentry in list(nx.connected_components(G)):
            if len(thisentry) == len(all_species):
                nwaybest.append(thisentry)
            else:
                for node in thisentry:
                    remnodes.add(node)
        #cleanup the graph
        for node in remnodes:
            G.remove_node(node)
        remnodes.clear()
        # print out the graph
        uniquenodes = set()
        with open(output.blast_network, "w") as f:
            for thisedge in G.edges:
                agene = "_".join(thisedge[0].split("_")[1::])
                bgene = "_".join(thisedge[1].split("_")[1::])
                print("{}\t{}".format(agene, bgene), file = f)
                uniquenodes.add(thisedge[0])
                uniquenodes.add(thisedge[1])
        with open(output.acceptable_prots, "w") as f:
            for thisnode in uniquenodes:
                thisgene = "_".join(thisnode.split("_")[1::])
                print(thisgene, file = f)
        # print out the list of genes
        CCs = []
        for thisentry in list(nx.connected_components(G)):
            ccdict = {"rbh": "rbh{}way_{}_{}".format(
                len(all_species), "_".join(all_species), len(CCs)+1)}
            for node in thisentry:
                thisgene = "_".join(node.split("_")[1::])
                ccdict["{}_gene".format(gene_to_species[node])] = thisgene
            CCs.append(ccdict)
        genesdf = pd.DataFrame(CCs)
        genesdf["gene_group"] = "None"
        # Convert the gene names to strings in case they are not yet.
        #  Sometimes they are numbers, and this will cause problems.
        for thisspecies in sorted(all_species):
            genesdf["{}_gene".format(thisspecies)] = genesdf[
                "{}_gene".format(thisspecies)].astype(str)

        # now add the other info
        column_add = []
        for thisspecies in sorted(all_species):
            genesdf["{}_scaf".format(thisspecies)] = genesdf[
                "{}_gene".format(thisspecies)].map(
                    dict(zip(chrom_dicts[thisspecies].prot,
                             chrom_dicts[thisspecies].scaf)) )
            genesdf["{}_pos".format(thisspecies)] = genesdf[
                "{}_gene".format(thisspecies)].map(
                    dict(zip(chrom_dicts[thisspecies].prot,
                             chrom_dicts[thisspecies].start)))
            column_add = column_add + ["{}_gene".format(thisspecies),
                                       "{}_scaf".format(thisspecies),
                                       "{}_pos".format(thisspecies)]

        # add the gene_group info
        for index, row in genesdf.iterrows():
            for thisspecies in all_species:
                this_gene = row["{}_gene".format(thisspecies)]
                if this_gene in prot_to_group:
                    genesdf.loc[index, "gene_group"] = prot_to_group[this_gene]

        # now add the information about the splits
        for thisspecies in all_species:
            chrom_to_breaks = {}
            for entry in config["species"][thisspecies]["manual_breaks"]:
                split = entry.split(":")
                chrom = split[0]
                chrombreak = int(split[1])
                if chrom not in chrom_to_breaks:
                    chrom_to_breaks[chrom] = [0, 9999999999]
                chrom_to_breaks[chrom].append(chrombreak)

            # now we modify the cells
            genesdf["{}_breakchrom".format(thisspecies)] = ""
            for index, row in genesdf.iterrows():
                thisscaf = row["{}_scaf".format(thisspecies)]
                thispos  = row["{}_pos".format(thisspecies)]
                if thisscaf not in chrom_to_breaks:
                    chrom_to_breaks[thisscaf] = [0, 9999999999]
                breakpoints = sorted(chrom_to_breaks[thisscaf])
                for i in range(len(breakpoints) - 1):
                    if (breakpoints[i] <= thispos) and (thispos < breakpoints[i+1]):
                        genesdf.loc[index, "{}_breakchrom".format(thisspecies)] = "{}:{}-{}".format(
                            thisscaf, breakpoints[i], breakpoints[i+1]).replace("9999999999", "end")

        # now add the indices of each gene, specific to this pairwise comparison
        for thisspecies in all_species:
            genesdf = genesdf.sort_values(["{}_scaf".format(thisspecies),
                                           "{}_pos".format(thisspecies)],
                                          ascending = True)
            genesdf["{}_ix".format(thisspecies)] = genesdf.groupby(["{}_scaf".format(thisspecies)]).cumcount()
            genesdf["{}_break_ix".format(thisspecies)] = genesdf.groupby(["{}_breakchrom".format(thisspecies)]).cumcount()

        genesdf.to_csv(output.rbh, sep="\t", index = False)

def calc_D_for_y_and_x(df, xsample, ysample):
    """
    This calculates D for both the x and y axes.
    Defined in the 2020 vertebrate synteny paper.
    """
    # some variable names in this for loop are "x" but it doesn't matter.
    #  everything important is variable between x and y
    for i in [0,1]:
        if i == 0:
            thisdir = xsample
            oppositexy = ysample
        elif i == 1:
            thisdir = ysample
            oppositexy = xsample
        df = df.sort_values(by = ["{}_breakchrom".format(thisdir),
                                  "{}_break_ix".format(thisdir)],
                            ascending = True)
        df = df.reset_index(drop = True)
        breaks = df["{}_breakchrom".format(thisdir)].unique()
        thisdir_dfs = []
        # this just calculates Dx
        for thisx in breaks:
            xdf = df.loc[df["{}_breakchrom".format(thisdir)] == thisx, ].copy()
            xdf = xdf.reset_index(drop=True)
            df2 = pd.get_dummies(xdf["{}_breakchrom".format(oppositexy)])
            df2_xiL = df2.apply(lambda x: x.rolling(20).mean(), axis = 0)
            df2_xiR = df2.apply(lambda x: x.iloc[::-1].rolling(20).mean(), axis = 0).iloc[::-1]
            df2_xiR = df2_xiR.set_index(df2_xiR.index - 1)
            df2_xiR = df2_xiR.iloc[1:]
            subtractdf = df2_xiR.fillna(0) - df2_xiL.fillna(0)
            xdf["{}_D".format(thisdir)] = subtractdf.apply(lambda x: np.sqrt(np.square(x).sum()), axis = 1)
            thisdir_dfs.append(xdf)
        df = pd.concat(thisdir_dfs)
    df.reset_index(drop=True, inplace = True)
    return df

def calculate_FET(genesdf, scafdict):
    """
    Takes in a rbh file and calculates the false discovery rate using
      Fisher's Exact Test.

    Inputs:
      - genesdf - a pandas dataframe of RBH
      - species_list - a list of species?? why is this here
      - minscafsizelist

    Failure cases:
      - there are more than two species in the genesdf
    """
    all_species = [x.replace("_gene", "") for x in genesdf.columns if x.endswith("_gene")]
    # make sure there are only two species since this method only works with that
    if len(all_species) > 2:
        raise IOError("This method can only be performed with two species. This has {}".format(all_species))

    # now filter rows based on the scaffolds that we allow
    for i in [0,1]:
        genesdf = genesdf.loc[genesdf["{}_scaf".format(all_species[i])].isin(scafdict[all_species[i]]), ]

    genesdf["whole_FET"] = -1
    genesdf["break_FET"] = -1
    # now perform Fisher's Exact Test
    if len(all_species) == 2:
        sp1 = list(sorted(all_species))[0]
        sp2 = list(sorted(all_species))[1]
        for sp1scaf, sp2scaf, FET in [
                ["{}_scaf".format(sp1), "{}_scaf".format(sp2), "whole_FET"],
                ["{}_breakchrom".format(sp1), "{}_breakchrom".format(sp2), "break_FET"]]:
            # make this table for the chroms
            sp1_chroms = genesdf[sp1scaf].unique()
            sp2_chroms = genesdf[sp2scaf].unique()
            combos = {(x, y): 1 for x in sp1_chroms for y in sp2_chroms}
            for thiscombo in combos:
                sp1_chrom = thiscombo[0]
                sp2_chrom = thiscombo[1]
                in1in2  =  len(genesdf.loc[(genesdf[sp1scaf] == sp1_chrom) & (genesdf[sp2scaf] == sp2_chrom),])
                out1in2 =  len(genesdf.loc[(genesdf[sp1scaf] != sp1_chrom) & (genesdf[sp2scaf] == sp2_chrom),])
                in1out2 =  len(genesdf.loc[(genesdf[sp1scaf] == sp1_chrom) & (genesdf[sp2scaf] != sp2_chrom),])
                out1out2 = len(genesdf.loc[(genesdf[sp1scaf] != sp1_chrom) & (genesdf[sp2scaf] != sp2_chrom),])
                table = [[in1in2, out1in2], [in1out2, out1out2]]
                oddsratio, pvalue = stats.fisher_exact(table, alternative="greater")
                combos[thiscombo] = pvalue * len(combos)
            for index, row in genesdf.iterrows():
                rowsp1 = row[sp1scaf]
                rowsp2 = row[sp2scaf]
                genesdf.loc[index, FET] = combos[(row[sp1scaf], row[sp2scaf])]
        #genesdf = genesdf.groupby(["{}_scaf".format(sp1), "{}_scaf".format(sp2)])

    return genesdf

def h2r(h):
    """
    converts hex to rgb
    """
    h = h.replace("#","").upper()
    return [x/255 for x in list(int(h[i:i+2], 16) for i in (0, 2, 4))]

def inverse_color(hexcolor):
    """
    Takes in a hex color and determines if the text should be black or white

    This is used for determining the color of text in the cells

    taken from: https://stackoverflow.com/questions/3942878
    """
    red,green,blue = [x*255 for x in h2r(hexcolor)]

    if hexcolor == "#000000":
        return "#000000"

    if (red*0.299 + green*0.587 + blue*0.114) > 186:
        return "#000000"
    else:
        return "#ffffff"

def synteny_plot_sheet(df_file, plotdf_file, synplot,
                 xsample, ysample,
                 xorder,  yorder,
                 xbreaks, ybreaks,
                 orthology_method,
                 sort_y_by_x = True,
                 prot_to_color_name = None,
                 prot_to_color_dir  = None,
                 prot_to_color_hmm_results = None):
    """
    If the user provided a plot order, then we should not skip any scaffolds.

    This is the main plotting script for the synteny plot
    """
    import pandas as pd
    import seaborn as sns; sns.set()
    import matplotlib
    import matplotlib.pyplot as plt
    import matplotlib.ticker as ticker
    #import matplotlib.patches as mplpatches
    from matplotlib.ticker import StrMethodFormatter, NullFormatter
    import numpy as np
    # set seaborn stuff

    prot_to_color_mode = False

    # check if we are in prot_to_color_mode
    if prot_to_color_name and os.path.exists(prot_to_color_dir):
        prot_to_color_mode = True

    # read in the rbh file
    df = pd.read_csv(df_file, delimiter="\t")

    # first filter out the chroms by min size
    s2c2s = species_to_chrom_to_size(config)
    df = calculate_FET(df, s2c2s)
    df = calc_D_for_y_and_x(df, xsample, ysample)

    # now make a separate df for x and y for plotting order
    xdf = False
    xsorter = xorder
    if len(xorder) == 0:
        # sort by largest to smallest
        xgb = df.groupby(by=["{}_scaf".format(xsample)], dropna=False)
        xsorter = list(xgb.size().sort_values(ascending = False).index)
    xgb = df.groupby(by=["{}_scaf".format(xsample)])
    # sorts the rows by the scaf order, and within the scafs by the gene index
    xdf = pd.concat([xgb.get_group(x).sort_values(
        by = ["{}_ix".format(xsample)], ascending=True).reset_index(drop=True)
                           for x in xsorter]).reset_index(drop=True)
    xdf["{}_plotindex".format(xsample)] = xdf.index
    #print(xdf[[x for x in xdf.columns if xsample in x]])
    xsorter_to_cumsum = [0]
    for i in range(1,len(xsorter)):
        xsorter_to_cumsum.append( xsorter_to_cumsum[i-1] + s2c2s[xsample][xsorter[i-1]])
    x_to_cumsum = {xsorter[i]:xsorter_to_cumsum[i] for i in range(len(xsorter_to_cumsum))}
    xdf["{}_plotpos".format(xsample)] = xdf["{}_scaf".format(xsample)].map(x_to_cumsum) + xdf["{}_pos".format(xsample)]

    # now make a separate df for x and y for plotting order
    ydf = False
    ysorter = yorder
    if sort_y_by_x:
        ygb = df.groupby(by=["{}_scaf".format(ysample),
                             "{}_scaf".format(xsample),
                             "whole_FET"], dropna=False).size().reset_index()
        ygb.columns = ["{}_scaf".format(ysample), "{}_scaf".format(xsample),
                       "whole_FET", "Count"]
        ygb = ygb.sort_values(by = ["{}_scaf".format(ysample), "whole_FET"],
                              ascending = [True, True]
                              ).drop_duplicates(subset=["{}_scaf".format(ysample)]
                              ).reset_index(drop=True)
        xscafs = list(set(ygb["{}_scaf".format(xsample)]))
        ygb = ygb.groupby(by = ["{}_scaf".format(xsample)])

        ydf = pd.concat([ygb.get_group(x).sort_values(
            by = ["Count"], ascending=False).reset_index(drop=True)
                               for x in xsorter if x in xscafs]
                        ).reset_index(drop=True)
        ysorter = list(ydf["{}_scaf".format(ysample)])
    else:
        if len(yorder) == 0:
            # sort by largest to smallest
            ygb = df.groupby(by=["{}_scaf".format(ysample)], dropna=False)
            ysorter = list(ygb.size().sort_values(ascending = False).index)
    ygb = xdf.groupby(by=["{}_scaf".format(ysample)])
    ydf = pd.concat([ygb.get_group(x).sort_values(
        by = ["{}_ix".format(ysample)], ascending=True).reset_index(drop=True)
                           for x in ysorter]).reset_index(drop=True)
    ydf["{}_plotindex".format(ysample)] = ydf.index
    ysorter_to_cumsum = [0]
    for i in range(1,len(ysorter)):
        ysorter_to_cumsum.append( ysorter_to_cumsum[i-1] + s2c2s[ysample][ysorter[i-1]])
    y_to_cumsum = {ysorter[i]:ysorter_to_cumsum[i] for i in range(len(ysorter_to_cumsum))}
    ydf["{}_plotpos".format(ysample)] = ydf["{}_scaf".format(ysample)].map(y_to_cumsum) + ydf["{}_pos".format(ysample)]

    # this is what we plot
    plotdf = ydf

    # Options for plotting
    #sns.set(rc={'text.usetex' : True})
    logging.getLogger('matplotlib.font_manager').setLevel(logging.ERROR)
    sns.set_style("ticks", {'font.family': ['sans-serif'],
                                'font.sans-serif': ['Helvetica'],
                                'grid.color': '.95'})
    # Preserve the vertical order of embedded images:
    matplotlib.rcParams['image.composite_image'] = False
    # text as font in pdf
    matplotlib.rcParams['pdf.fonttype'] = 42
    matplotlib.rcParams['ps.fonttype'] = 42

    # now make a scatter plot
    #figDouble = 16
    figWidth  = 14
    figHeight = 18
    fig = plt.figure(figsize=(figWidth,figHeight))

    #set the panel dimensions
    panelWidth = 4
    panelHeight = 4
    dpanel_width = 0.25
    #find the margins to center the panel in figure
    leftStart = 2.5
    secondLeftStart = 8.5
    bottomMargin = 12.5
    # panel1 will host the index-based plot
    plt.gcf().text((leftStart-0.75)/figWidth,
                    (bottomMargin+panelHeight+0.25)/figHeight,
                   "a", weight = "bold",
                   fontsize = 20, ha = "left")

    panel1 = plt.axes([leftStart/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         panelHeight/figHeight])     #height
    panelxd = plt.axes([leftStart/figWidth, #left
                         (bottomMargin+panelHeight+0.5)/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         dpanel_width/figHeight])     #height
    panelyd = plt.axes([(leftStart+panelWidth + 0.5)/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         dpanel_width/figWidth,   #width
                         panelHeight/figHeight])     #height

    # panel2 will host the position-based plot
    plt.gcf().text((secondLeftStart-0.75)/figWidth,
                    (bottomMargin+panelHeight+0.25)/figHeight,
                   "b", weight = "bold",
                   fontsize = 20, ha = "left")
    panel2 = plt.axes([secondLeftStart/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         panelHeight/figHeight])     #height
    pospanelxd = plt.axes([secondLeftStart/figWidth, #left
                         (bottomMargin+panelHeight+0.5)/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         dpanel_width/figHeight])     #height
    pospanelyd = plt.axes([(secondLeftStart+panelWidth + 0.5)/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         dpanel_width/figWidth,   #width
                         panelHeight/figHeight])     #height


    panellg = plt.axes([ 0.4/figWidth, #left
                         4/figHeight,    #bottom
                         0.1/figWidth,   #width
                         figHeight/figHeight])     #height

    panel1.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=True,
                        left=False, labelleft=True,
                        right=False, labelright=True,
                        top=False, labeltop=False)
    panel2.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=True,
                        left=False, labelleft=True,
                        right=False, labelright=True,
                        top=False, labeltop=False)
    for xpanels in [panelxd, pospanelxd]:
        xpanels.tick_params(axis='both',which='both',
                            bottom=False, labelbottom=False,
                            left=False, labelleft=False,
                            right=False, labelright=False,
                            top=False, labeltop=False)
    for ypanels in [panelyd, pospanelyd]:
        ypanels.tick_params(axis='both',which='both',
                            bottom=False, labelbottom=False,
                            left=False, labelleft=False,
                            right=False, labelright=False,
                            top=False, labeltop=False)
    panellg.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    # set the panel linewidth thinner
    for this_panel in [panel1, panelxd, panelyd, pospanelxd, pospanelyd]:
        for axis in ['top','bottom','left','right']:
            this_panel.spines[axis].set_linewidth(0.5)
    # turn off the axis spines
    for this_panel in [panelxd, panelyd, pospanelxd, pospanelyd]:
        this_panel.spines['top'].set_visible(False)
        this_panel.spines['right'].set_visible(False)

    # set labels
    plt.gcf().text((leftStart + (panelWidth/2))/figWidth,
                   17.35/figHeight,
                   "{} vs {} synteny (gene indices)".format(xsample, ysample),
                   fontsize = 15, ha = "center")
    plt.gcf().text((secondLeftStart + (panelWidth/2))/figWidth,
                   17.35/figHeight,
                   "{} vs {} synteny (chromosome coordinates)".format(xsample, ysample),
                   fontsize = 15, ha = "center")



    color_list = []
    alpha_list = []
    legend_elements = []
    print("this is plotdf")
    print(plotdf)
    if prot_to_color_mode:
        # parse the colorset
        LG = oc.LG_db(prot_to_color_name, prot_to_color_dir,
                      prot_to_color_hmm_results)
        plotdf = LG.color_dataframe(plotdf)
        # handle the legend now
        legend_elements += [
          Patch(facecolor=LG.group_to_color[key],
                edgecolor='black', lw = 0,
                label=key) for key in LG.group_to_color
         if key not in ["none", "na", "NA"]]
    else:
        # we're not in prot_to_color_mode, so check to make sure there is a color
        if "color" not in plotdf.columns:
            plotdf["color"] = "#000000"
        else:
            # if there is a color column, make sure that it is a real column
            plotdf["color"] = plotdf["color"].apply(lambda x: x if "#" in x else "#000000")
        # We also have to check if there are groups already.
        #  There shouldn't be but we must check anyway.
        if "gene_group" not in plotdf.columns:
            plotdf["gene_group"] = None
        else:
            # there's already a column, so leave the groups alone
            pass


    legend_elements += [
      Line2D([], [],
            marker='o',
            markerfacecolor=[0,0,0,0.333],
            markeredgecolor='black',
            markeredgewidth = 0,
            markersize = 10,
            linewidth = 0,
            label="p > 0.05"),
      Line2D([], [],
            marker='o',
            markerfacecolor=[0,0,0,1],
            markeredgecolor='black',
            markeredgewidth = 0,
            markersize = 10,
            linewidth = 0,
            label="p <= 0.05")]
    panellg.legend(title="Linkage Group\nColors", handles=legend_elements,
                   fontsize = 10, loc='center left')

    [s.set_visible(False) for s in panellg.spines.values()]
    [t.set_visible(False) for t in panellg.get_xticklines()]
    [t.set_visible(False) for t in panellg.get_yticklines()]

    # first the index section
    x = np.array(plotdf["{}_plotindex".format(xsample)])
    y = np.array(plotdf["{}_plotindex".format(ysample)])
    xmax = max(plotdf["{}_plotindex".format(xsample)])
    ymax = max(plotdf["{}_plotindex".format(ysample)])

    color_list = [h2r(x) for x in plotdf["color"]]
    #print(color_list)
    alpha_list = [[0.25] if x > 0.05 else [0.9] for x in plotdf["break_FET"]]
    # make the black dots a little lighter
    alpha_list = [[0.75] if (plotdf["break_FET"][i] <= 0.05 and plotdf["color"][i] == "#000000") else alpha_list[i] \
                  for i in range(len(alpha_list))]
    composite_color = np.array([color_list[i] + alpha_list[i]
                                for i in range(len(color_list))])

    posx = np.array(plotdf["{}_plotpos".format(xsample)])
    posy = np.array(plotdf["{}_plotpos".format(ysample)])

    pos_xmax = sum([s2c2s[xsample][x] for x in
                plotdf["{}_scaf".format(xsample)].unique()
                if x in s2c2s[xsample]])
    pos_ymax = sum([s2c2s[ysample][x] for x in
                plotdf["{}_scaf".format(ysample)].unique()
                if x in s2c2s[ysample]])
    # sort so the colors are on top
    # make two sets of values to use to make sure colors are on top
    zorder = [-999     if c == "#000000" else 1 for c in list(plotdf["color"])]
    order = np.argsort(zorder)

    panel1.scatter(x[order], y[order], color = composite_color[order],
                   ec = None, s=6, linewidths = 0)
    panel2.scatter(posx[order], posy[order], color = composite_color[order],
                   ec = None, s=6, linewidths = 0)
    # set mins and max for index-panel
    panel1.set_xlim([0, xmax])
    panel1.set_ylim([0, ymax])
    # for position-panel
    panel2.set_xlim([0, pos_xmax])
    panel2.set_ylim([0, pos_ymax])

    # now that we've plotted everything, save the dataframe
    # Header needs to be True, otherwise it will not be read in correctly for other tools
    plotdf.to_csv(plotdf_file, sep ="\t", header = True, index = None)

    # plot vertical x lines
    xlabelpos   = [] # x scaf name positions
    xlabels     = [] # x scaf labels
    ylabelpos   = []
    ylabels     = []
    xlinepos    = [] # delimits the scafs
    ylinepos    = []
    xbreakpos   = [] # delimits where the breaks are
    ybreakpos   = []
    xcountpos   = [] # positions of where gene counts are
    xcountlabel = [] # how many genes are in each scaffold
    ycountpos   = []
    ycountlabel = []
    pos_xlabelpos   = [] # x scaf name positions
    pos_xlabels     = [] # x scaf labels
    pos_ylabelpos   = []
    pos_ylabels     = []
    pos_xlinepos    = [] # delimits the scafs
    pos_ylinepos    = []
    pos_xbreakpos   = [] # delimits where the breaks are
    pos_ybreakpos   = []
    pos_xcountpos   = [] # positions of where gene counts are
    pos_xcountlabel = [] # how many genes are in each scaffold
    pos_ycountpos   = []
    pos_ycountlabel = []


    # first do this for the plot with the indices
    # X-AXIS LABELS AND VERTICAL LINES
    tempgb = plotdf.sort_values(by=["{}_plotindex".format(xsample)]).groupby(by=["{}_scaf".format(xsample)])
    # we can get these based on index
    for xscaf in xsorter:
        # sort the indices
        minpos = tempgb.get_group(xscaf)["{}_plotindex".format(xsample)].min()
        maxpos = tempgb.get_group(xscaf)["{}_plotindex".format(xsample)].max()
        midpos = ((maxpos - minpos)/2) + minpos
        xlabelpos.append(midpos)
        xlabels.append(xscaf)
        # now for the positions
        pos_xlabels.append(xscaf)
        pos_xlabelpos.append(x_to_cumsum[xscaf] + (s2c2s[xsample][xscaf]/2))
    # for the scaf labels for the chrom size

    # find vertical lines, get everything except the last, and add 0.5 to each value
    vlinesdf = tempgb.last().reset_index()
    tempxdf = vlinesdf.loc[vlinesdf["{}_scaf".format(xsample)].isin(xsorter[:-1]), ]
    xlinepos = list(tempxdf["{}_plotindex".format(xsample)] + 0.5)
    pos_xlinepos = xsorter_to_cumsum[1::]
    # get the positions and quantities of genes
    xcountpos = [0] + list(vlinesdf.sort_values(by=["{}_plotindex".format(xsample)], 
                                                ascending = True)["{}_plotindex".format(xsample)])
    xcountlabel = [str(x) for x in xcountpos]
    # now indices
    pos_xcountpos = [0] + list(vlinesdf.sort_values(by=["{}_plotindex".format(xsample)], 
                                                ascending = True)["{}_plotpos".format(xsample)])
    pos_xcountlabel = xcountlabel

    # Y-AXIS LABELS AND HORIZONTAL LINES
    tempgb = plotdf.sort_values(by=["{}_plotindex".format(ysample)]).groupby(by=["{}_scaf".format(ysample)])
    for yscaf in ysorter:
        minpos = tempgb.get_group(yscaf)["{}_plotindex".format(ysample)].min()
        maxpos = tempgb.get_group(yscaf)["{}_plotindex".format(ysample)].max()
        midpos = ((maxpos - minpos)/2) + minpos
        ylabelpos.append(midpos)
        ylabels.append(yscaf)
        # now for the positions
        pos_ylabels.append(yscaf)
        pos_ylabelpos.append(y_to_cumsum[yscaf] + (s2c2s[ysample][yscaf]/2))

    #find horizontal lines, get everything except the last, and add 0.5 to each value
    hlinesdf = tempgb.last().reset_index()
    tempydf = hlinesdf.loc[hlinesdf["{}_scaf".format(ysample)].isin(ysorter[:-1]), ]
    ylinepos = list(tempydf["{}_plotindex".format(ysample)] + 0.5)
    pos_ylinepos = ysorter_to_cumsum[1::]
    # get the positions and quantities of genes
    ycountpos = [0] + list(hlinesdf["{}_plotindex".format(ysample)])
    ycountlabel = ycountpos
    # now indices
    pos_ycountpos = [0] + list(hlinesdf.sort_values(by=["{}_plotindex".format(ysample)], 
                                                ascending = True)["{}_plotpos".format(ysample)])
    pos_ycountlabel = [0] + list(hlinesdf.sort_values(by=["{}_plotindex".format(ysample)], 
                                                ascending = True)["{}_plotindex".format(ysample)])

    # FIND VERTICAL BREAKS
    tempxdf = plotdf.sort_values(by=["{}_plotindex".format(xsample)]).groupby(
        by=["{}_breakchrom".format(xsample)]).last().reset_index()
    xbreakpos = [x for x in list(tempxdf["{}_plotindex".format(xsample)] + 0.5)
                 if ((x not in xlinepos) and (x < xmax))]
    tempxdf = tempxdf.loc[~tempxdf["{}_breakchrom".format(xsample)].str.contains("end"), ]
    pos_xbreakpos = [x for x in list(tempxdf["{}_plotpos".format(xsample)] + 0.5)
                 if ((x not in pos_xlinepos) and (x < pos_xmax))]

    # FIND HORIZONTAL BREAKS
    tempydf = plotdf.sort_values(by=["{}_plotindex".format(ysample)]).groupby(
        by=["{}_breakchrom".format(ysample)]).last().reset_index()
    ybreakpos = [y for y in list(tempydf["{}_plotindex".format(ysample)] + 0.5)
                 if ((y not in ylinepos) and (y < ymax))]
    tempydf = tempydf.loc[~tempydf["{}_breakchrom".format(ysample)].str.contains("end"), ]
    pos_ybreakpos = [y for y in list(tempydf["{}_plotindex".format(ysample)])
                 if ((y not in pos_ylinepos) and (y < pos_ymax))]


    linecolor="#8FA0B5"
    #plot vertical lines and breaks
    for xval in xlinepos:
        panel1.axvline(x=xval, color=linecolor, lw=0.5)
    for xval in pos_xlinepos:
        panel2.axvline(x=xval, color=linecolor, lw=0.5)
    for xval in xbreakpos:
        panel1.axvline(x=xval, color=[0,0,0,0.35], lw=0.5, linestyle="dotted")
    for xval in pos_xbreakpos:
        panel2.axvline(x=xval, color=[0,0,0,0.35], lw=0.5, linestyle="dotted")
    #plot horizontal lines and breaks
    for yval in ylinepos:
        panel1.axhline(y=yval, color=linecolor, lw=0.5)
    for yval in pos_ylinepos:
        panel2.axhline(y=yval, color=linecolor, lw=0.5)
    for yval in ybreakpos:
        panel1.axhline(y=yval, color=[0,0,0,0.35], lw=0.5, linestyle="dotted")
    for yval in pos_ybreakpos:
        panel2.axhline(y=yval, color=[0,0,0,0.35], lw=0.5, linestyle="dotted")

    # plot x axis labels
    #index plotting
    panel1.tick_params(bottom=True, labelbottom = True, top = False, labeltop = False)
    panel1.set_xticks(xlabelpos)
    panel1.set_xticklabels(xlabels, fontsize=8, rotation=90)
    panel1.set_xlabel(xsample + " scaffolds")
    #position plotting
    panel2.tick_params(bottom=True, labelbottom = True, top = False, labeltop = False)
    panel2.set_xticks(pos_xlabelpos)
    panel2.set_xticklabels(pos_xlabels, fontsize=8, rotation=90)
    panel2.set_xlabel(xsample + " scaffolds")

    axT = panel1.twiny()
    axT.tick_params(top = True, labeltop = True)
    axT.set_xticks(xcountpos)
    axT.set_xticklabels(xcountlabel, fontsize = 8, rotation=90)
    axTT = panel2.twiny()
    axTT.tick_params(top = True, labeltop = True)
    axTT.set_xticks(pos_xcountpos)
    axTT.set_xticklabels(pos_xcountlabel, fontsize = 8, rotation=90)

    # plot y axis labels
    # index plotting
    panel1.tick_params(left=True, labelleft = True, right = False, labelright = False)
    panel1.set_yticks(ylabelpos)
    panel1.set_yticklabels(ylabels, fontsize=8, rotation=0)
    panel1.set_ylabel(ysample + " scaffolds")
    #position plotting
    panel2.tick_params(left=True, labelleft = True, right = False, labelright = False)
    panel2.set_yticks(pos_ylabelpos)
    panel2.set_yticklabels(pos_ylabels, fontsize=8, rotation=0)
    panel2.set_ylabel(ysample + " scaffolds")

    # for indices
    axR = panel1.twinx()
    axR.tick_params(right = True, labelright = True)
    axR.set_yticks(ycountpos)
    axR.set_yticklabels(ycountlabel, fontsize = 8)
    # for positions
    axRR = panel2.twinx()
    axRR.tick_params(right = True, labelright = True)
    axRR.set_yticks(pos_ycountpos)
    axRR.set_yticklabels(pos_ycountlabel, fontsize = 8)

    ## turn on x-axis ticks on the Dx plot
    #newarrlabels = [round(x/1000000, 1) for x in newarr]
    #panelxd.tick_params(top=True, labeltop=True)
    #panelxd.set_xticks(newarr)
    #panelxd.set_xticklabels(newarrlabels, fontsize=8, rotation=90)
    #panelxd.xaxis.set_label_position("top")
    #panelxd.set_xlabel("Mb")

    ## turn on y-axis ticks on the Dy plot
    #newarrlabels = [round(x/1000000, 1) for x in newarr]
    #panelyd.tick_params(right=True, labelright=True)
    #panelyd.set_yticks(newarr)
    #panelyd.set_yticklabels(newarrlabels, fontsize=8)
    #panelyd.yaxis.set_label_position("right")
    #panelyd.set_ylabel("Mb")

    # set the x and y labels on Dy and Dx
    # by indices
    panelxd.bar(x = plotdf["{}_plotindex".format(xsample)],
                height=plotdf["{}_D".format(xsample)],
                width = 1,
                align = "center", lw=0, color="blue", zorder = 2)
    panelxd.set_xlim([0,xmax])
    panelxd.set_ylabel('Dx', fontsize=10)

    # now by position
    plotdf = plotdf.sort_values(by=["{}_plotpos".format(xsample)]).reset_index()
    plotdf["{}_Dwidths".format(xsample)] = plotdf["{}_plotpos".format(xsample)].diff().fillna(0)

    pospanelxd.bar(x = plotdf["{}_plotpos".format(xsample)],
                height=plotdf["{}_D".format(xsample)],
                width = plotdf["{}_Dwidths".format(xsample)],
                align = "center", lw=0, color="blue", zorder = 2)
    pospanelxd.set_xlim([0,pos_xmax])
    pospanelxd.set_ylabel('Dx', fontsize=10)

    # by indices
    panelyd.barh(y = plotdf["{}_plotindex".format(ysample)],
                width=plotdf["{}_D".format(ysample)],
                height = 1,
                align = "center", lw=0, color="blue", zorder = 2)
    panelyd.set_ylim([0,ymax])
    panelyd.set_xlabel('Dy', fontsize=10)

    # now by position
    plotdf = plotdf.sort_values(by=["{}_plotpos".format(ysample)]).reset_index()
    plotdf["{}_Dwidths".format(ysample)] = plotdf["{}_plotpos".format(ysample)].diff().fillna(0)

    pospanelyd.barh(y = plotdf["{}_plotpos".format(ysample)],
                width=plotdf["{}_D".format(ysample)],
                height = plotdf["{}_Dwidths".format(ysample)],
                align = "center", lw=0, color="blue", zorder = 2)

    pospanelyd.set_ylim([0,pos_ymax])
    pospanelyd.set_xlabel('Dy', fontsize=10)

    # TABLE OF THE CHROMOSOME PIECES and significance
    pd.set_option('display.float_format', '{:.2E}'.format)
    table_title_font_size = 11
    rowheight = 0.14
    cutoff = 0.1

    # table measurements
    table_left_margin = 2.15
    left_table_width = 3.9
    middle_table_width = 2.9
    right_table_width = 3.4
    table_spacing = 0.4
    cde_h_offset = 0.15
    cde_v_offset = 0.1

    gb =  plotdf.loc[plotdf["break_FET"] <= cutoff, ].groupby(by=["{}_breakchrom".format(xsample), "{}_breakchrom".format(ysample), "break_FET"]).size().reset_index()
    gb.columns = ["{} scaf".format(xsample), "{} scaf".format(ysample), "p (FET)", "Count"]
    gb = gb.sort_values(by=["Count", "{} scaf".format(xsample), "{} scaf".format(ysample)],
                        ascending = False).reset_index(drop=True)
    gb["p (FET)"] = gb["p (FET)"].apply(lambda x: "{:.2e}".format(x))
    gb["{} scaf".format(xsample)] = gb["{} scaf".format(xsample)].apply(
        lambda x: " : ".join(str(x).split(":")))
    gb["{} scaf".format(ysample)] = gb["{} scaf".format(ysample)].apply(
        lambda x: " : ".join(str(x).split(":")))

    plt.gcf().text((table_left_margin + left_table_width + (2*table_spacing) + \
                    middle_table_width + (right_table_width/2))/figWidth,
                    (bottomMargin-1.25)/figHeight,
                   "{} vs {} FET, chrom. pieces".format(xsample, ysample),
                   fontsize = table_title_font_size, ha = "center")
    plt.gcf().text((table_left_margin + left_table_width + (2*table_spacing) + \
                    middle_table_width - cde_h_offset)/figWidth,
                    (bottomMargin-1.25 + cde_v_offset)/figHeight,
                   "e", weight = "bold",
                   fontsize = 20, ha = "left")
    tableheight = rowheight*(len(gb)+1)

    chrompiecetable = plt.axes([(table_left_margin + left_table_width + table_spacing + middle_table_width + table_spacing)/figWidth, #left
                         (bottomMargin - tableheight- 1.35)/figHeight,    #bottom
                         right_table_width/figWidth,   #width
                         tableheight/figHeight])     #height
    chrompiecetable.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    if len(gb.values) > 0:
        thistab_chrompiece = chrompiecetable.table(rowLabels=["{}".format(x) for x in gb.index],
                       cellText=gb.values,
                       colLabels=gb.columns,
                       cellLoc = "left",
                       colLoc  = "left",
                       edges = "horizontal",
                       bbox = [0,0,1,1])
        thistab_chrompiece.auto_set_column_width(col=list(range(len(gb.columns))))
        thistab_chrompiece.auto_set_font_size(False)
        thistab_chrompiece.set_fontsize(7)


    # TABLE OF WHOLE CHROMOSOME SIGNIFICANCE
    plt.gcf().text((table_left_margin + left_table_width + table_spacing + (middle_table_width*0.5))/figWidth,
                    (bottomMargin-1.25)/figHeight,
                   "{} vs {} FET, whole chroms.".format(xsample, ysample),
                   fontsize = table_title_font_size, ha = "center")
    plt.gcf().text((table_left_margin + left_table_width + (table_spacing) - cde_h_offset)/figWidth,
                    (bottomMargin-1.25 + cde_v_offset)/figHeight,
                   "d", weight = "bold",
                   fontsize = 20, ha = "left")
    gb2 = plotdf.loc[plotdf["whole_FET"] <= cutoff, ].groupby(by=["{}_scaf".format(xsample), "{}_scaf".format(ysample), "whole_FET"]).size().reset_index()
    gb2.columns = ["{} scaf".format(xsample), "{} scaf".format(ysample), "p (FET)", "Count"]
    gb2 = gb2.sort_values(by=["Count", "{} scaf".format(xsample), "{} scaf".format(ysample)],
                        ascending = False).reset_index(drop=True)
    gb2["p (FET)"] = gb2["p (FET)"].apply(lambda x: "{:.2e}".format(x))
    tableheight = rowheight*(len(gb2)+1)
    chromwholetable = plt.axes([(table_left_margin+left_table_width +table_spacing)/figWidth, #left
                         (bottomMargin - tableheight- 1.35)/figHeight,    #bottom
                         (middle_table_width)/figWidth,   #width
                         tableheight/figHeight])     #height
    chromwholetable.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    if len(gb2.values) > 0:
        thistab_chromwhole = chromwholetable.table(
                                rowLabels=["{}".format(x) for x in gb2.index],
                                cellText=gb2.values,
                                colLabels=gb2.columns,
                                cellLoc = "left",
                                colLoc  = "left",
                                edges = "horizontal",
                                bbox = [0,0,1,1])
        thistab_chromwhole.auto_set_column_width(col=list(range(len(gb2.columns))))
        thistab_chromwhole.auto_set_font_size(False)
        thistab_chromwhole.set_fontsize(7)


    # TABLE OF COLOR GROUP RESULTS
    plt.gcf().text((table_left_margin + (left_table_width/2))/figWidth,
                    (bottomMargin-1.25)/figHeight,
                   "{} vs {} groupings".format(xsample, ysample),
                   fontsize = table_title_font_size, ha = "center")
    plt.gcf().text((table_left_margin - cde_h_offset)/figWidth,
                    (bottomMargin-1.25 + cde_v_offset)/figHeight,
                   "c", weight = "bold",
                   fontsize = 20, ha = "left")
    gb3 = plotdf.loc[plotdf["whole_FET"] <= 1, ].groupby(by=["{}_scaf".format(xsample), "{}_scaf".format(ysample),"whole_FET", "gene_group"]).size().reset_index()
    gb3.columns = ["{} scaf".format(xsample), "{} scaf".format(ysample), "p (FET)", "Group", "Count"]
    gb3 = gb3.loc[gb3["Count"] >= 5, ]

    if prot_to_color_mode:
        # if we have color mappings from the gene group we're using, use those colors
        gb3["Color"] = gb3["Group"].map(LG.group_to_color)
    else:
        # otherwise, generate the group to color just for this block from our plotting df
        tempgroup_to_color_df = plotdf.groupby(
                 by=["gene_group"])["color"].value_counts(
                 ascending = False).rename("Counts").reset_index(
                 ).drop_duplicates("gene_group")
        tempgroup_to_color = dict(zip(tempgroup_to_color_df["gene_group"],
                                      tempgroup_to_color_df["color"]))
        gb3["Color"] = gb3["Group"].map(tempgroup_to_color)

    gb3 = gb3.sort_values(by=["{} scaf".format(xsample), "{} scaf".format(ysample), "p (FET)", "Count"],
                          ascending = [True, True, True, False]).reset_index(drop=True)
    gb3["p (FET)"] = gb3["p (FET)"].apply(lambda x: "{:.2e}".format(x))
    # swap the columns
    gb3 = gb3[["{} scaf".format(xsample), "{} scaf".format(ysample), "p (FET)", "Count", "Group", "Color"]]

    color_matrix = []
    for index, row in gb3.iterrows():
        # example from
        #  https://stackoverflow.com/questions/46663911
        # the_table[(1, 0)].set_facecolor("#56b5fd")
        base = ["w"] * len(gb3.columns)
        thiscolor = row["Color"] if row["Color"] != "#000000" else "w"
        base[-1] = thiscolor
        base[-2] = thiscolor
        color_matrix.append(base)

    #print(color_matrix)

    tableheight = rowheight*(len(gb3)+1)
    colortable = plt.axes([table_left_margin/figWidth, #left
                         (bottomMargin - tableheight- 1.35)/figHeight,    #bottom
                         left_table_width/figWidth,   #width
                         tableheight/figHeight])     #height
    colortable.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    if len(gb3.values) > 0:
        thistab_color = colortable.table(
                           rowLabels=["{}".format(x) for x in gb3.index],
                           cellText=gb3.values,
                           cellColours=color_matrix,
                           colLabels=gb3.columns,
                           cellLoc = "left",
                           colLoc  = "left",
                           #edges = "horizontal", #bug where this doesn't work with cell colors https://stackoverflow.com/questions/67890401/
                           bbox = [0,0,1,1])
        thistab_color.auto_set_column_width(col=list(range(len(gb3.columns))))
        thistab_color.auto_set_font_size(False)
        thistab_color.set_fontsize(7)


    #print(thistab_color._cells)
    for rowi in range(1,len(gb3)+1):
        for coli in [len(gb3.columns)-2, len(gb3.columns)-1]:
            inv = inverse_color(gb3.loc[rowi-1, "Color"])
            if inv == "#ffffff":
                thistab_color._cells[(rowi, coli)]._text.set_color(inv)

    print(gb)
    print()
    print(gb2)
    print()
    print(gb3)

    captionax = plt.axes([1.0/figWidth, #left
                          1.0/figHeight,    #bottom
                          (figWidth-2)/figWidth,   #width
                          1/figHeight])     #height
    captionax.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)

    # top text
    top_text = "{}: {} orthologs on {} {} scaffolds and {} {} scaffolds.".format(
                       orthology_method, len(plotdf),
                       len(plotdf["{}_scaf".format(xsample)].unique()), xsample,
                       len(plotdf["{}_scaf".format(ysample)].unique()), ysample)
    if prot_to_color_mode:
        top_text += " Colored by {}.".format(LG.color_method)
    plt.gcf().text(0.1/figHeight,
                   (figHeight-0.1)/figHeight,
                   top_text,
                   weight = "bold",
                   fontsize = 13, ha = "left", va="top")
    # caption
    if orthology_method == "diamond":
        orthology_method = "reciprocal best diamond blastp match between two species"
    elif orthology_method == "blastp":
        orthology_method = "reciprocal best blastp match between two species"
    t = [
        "(a) depicts the chromosomes/scaffolds of {} (x-axis) plotted".format(xsample),
        "against the chromosomes/scaffolds of {} (y_axis).".format(ysample),
        "Each dot in the plot represents an ortholog, specifically a {}.".format(orthology_method),
        "The unit of the x- and y-axes are the number of orthologous proteins between these two species:",
        "{} orthologs found between {} {} scaffolds and {} {} scaffolds.".format(
            len(plotdf),
            len(plotdf["{}_scaf".format(xsample)].unique()), xsample,
            len(plotdf["{}_scaf".format(ysample)].unique()), ysample),
        "If there are chromosome breaks, Fisher's exact test is used to calculate the",
        "significance of the interactions between the sub-chromosomal pieces. Otherwise",
        "Fisher's exact test is calculated on whole chromosomes.",
        "The opacity of the dots depict the significance from Fisher's exact test.",
        "Dots that are a solid color are in cells with a FET p-value less than or equal to 0.05.",
        "Dots that are translucent are in cells with a FET p-value greater than 0.05.",
        "The Dx and Dy values depict places where there may be sudden breaks in synteny.",
        "See the supplementary information the following paper for more information on Dx and Dy: Simakov, Oleg, et al. \"Deeply conserved synteny resolves early events in vertebrate evolution.\" Nature Ecology & Evolution 4.6 (2020): 820-830.",
        "(b) depicts the same information as panel a, but it is plotted in the",
        "organisms chromosome basepair coordinates rather than gene index.",
        "This is useful for visualizing gene-poor regions of the chromosomes",
        "(c) shows which gene groups are most prevalent in each chromosome pair.",
        "The FET p-value in this table corresponds to the whole-chormosome FET p-value",
        ", and is not a FET value of the correlation between the chromosome pair and the gene group.",
        "(d) shows chromosome-scale significance values.",
        "This table shows the same information as c, but does not factor in gene group information.",
        "(e) shows the FET p-values of the sub-chromosomal compartments. Useful for",
        "showing if single arms of chromosomes are correlated with other regions."
         ]
    t = " ".join(t)

    captext = captionax.text(0, 1, t, fontsize = 10, ha="left", va="top", wrap=True)


    for this_panel in [chrompiecetable, chromwholetable, colortable, captionax]:
        this_panel.spines['top'].set_visible(False)
        this_panel.spines['left'].set_visible(False)
        this_panel.spines['bottom'].set_visible(False)
        this_panel.spines['right'].set_visible(False)

    plt.savefig(synplot)

"""
This makes the synteny plot without doing any special coloring of the dots
"""
rule plot_synteny_nocolor:
    input:
        rbh = config["tool"] + "/step1-rbh/{analysis}_reciprocal_best_hits.rbh"
    output:
        rbh = config["tool"] + "/step2-figures/synteny_nocolor/{analysis}_xy_reciprocal_best_hits.plotted.rbh",
        xy  = config["tool"] + "/step2-figures/synteny_nocolor/{analysis}_xy_synteny.pdf",
        yx  = config["tool"] + "/step2-figures/synteny_nocolor/{analysis}_yx_synteny.pdf"
    threads:
        1
    params:
        analysis = lambda wildcards: wildcards.analysis,
        orthology_method = config["diamond_or_blastp"]
    run:
        xsample = params.analysis.split("_")[0]
        ysample = params.analysis.split("_")[1]
        xorder  = config["species"][xsample]["plotorder"] if "plotorder" in config["species"][xsample] else []
        yorder  = config["species"][ysample]["plotorder"] if "plotorder" in config["species"][ysample] else []
        xbreaks = config["species"][xsample]["manual_breaks"] if "manual_breaks" in config["species"][xsample] else []
        ybreaks = config["species"][ysample]["manual_breaks"] if "manual_breaks" in config["species"][ysample] else []

        # figure out how to sort the scaffolds
        sort_y_by_x = True
        if "sort_by_x_coord_blast" in config["species"][ysample]:
            sort_y_by_x = config["species"][ysample]["sort_by_x_coord_blast"]
        synteny_plot_sheet(input.rbh, output.rbh, output.xy,
                     xsample, ysample,
                     xorder, yorder,
                     xbreaks, ybreaks,
                     params.orthology_method,
                     sort_y_by_x = sort_y_by_x)
        # check again for sort
        if "sort_by_x_coord_blast" in config["species"][xsample]:
            sort_y_by_x = config["species"][xsample]["sort_by_x_coord_blast"]
        synteny_plot_sheet(input.rbh, output.rbh, output.yx,
                     ysample, xsample,
                     yorder, xorder,
                     ybreaks, xbreaks,
                     params.orthology_method,
                     sort_y_by_x = sort_y_by_x)

rule hmm_against_prots:
    input:
        hmm = lambda wildcards: os.path.join(
            config["prot_to_color"][wildcards.coloredby],
            [x for x in list(os.listdir(
            config["prot_to_color"][wildcards.coloredby]))
                                      if x.endswith(".hmm")][0]),
        proteins = config["tool"] + "/db/{sample}_prots.pep"
    output:
        hmm = config["tool"] + "/step0-blastp_results/{coloredby}_against_{sample}.hmmsearch"
    threads: min(10, int(workflow.cores/4))
    shell:
        """
        hmmsearch --incE 1E-5 \
          --tblout {output.hmm} \
          --cpu {threads} \
          --noali \
          --notextw \
          {input.hmm} \
          {input.proteins} > /dev/null
        """

rule filter_each_hmm_result:
    """
    The header fields are:
    # target name        accession  query name                         accession    E-value  score  bias   E-value  score  bias   exp reg clu  ov env dom rep inc description of target

    the headers for blastp outfmt 6 are:
      qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore

    gets the top five hits for each hmm and converts them to blastp outfmt 6 format
    """
    input:
        hmm = config["tool"] + "/step0-blastp_results/{coloredby}_against_{sample}.hmmsearch",
    output:
        hmm = config["tool"] + "/step0-blastp_results/{coloredby}_against_{sample}.hmmsearch.filt.blastp"
    threads: 1
    run:
        top_hits = 5
        outhandle = open(output.hmm, "w")
        with open(input.hmm, "r") as f:
            counter = 0
            prev = ""
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    fields = line.split()
                    qseqid = fields[2].replace(".aligned", "")
                    sseqid = fields[0]
                    pident = 50.0
                    length = 50.0
                    mismatch = 0
                    gapopen = 0
                    qstart = 0
                    qend = 0
                    sstart = 0
                    send = 0
                    evalue = float(fields[4])
                    bitscore = float(fields[5])
                    entry = [qseqid, sseqid, pident, length, mismatch, gapopen,
                             qstart, qend, sstart, send, evalue, bitscore]
                    counter += 1
                    if qseqid == prev:
                        if counter >= top_hits:
                            pass # don't do anything
                        else:
                            print("\t".join([str(x) for x in entry]), file = outhandle)
                    else:
                        print("\t".join([str(x) for x in entry]), file = outhandle)
                        counter = 0
                    prev = qseqid
        outhandle.close()

rule hmm_search_to_rbh:
    """
    converts a hmmsearch output to a reciprocal best hit file
    """
    input:
        hmm = config["tool"] + "/step0-blastp_results/{coloredby}_against_{sample}.hmmsearch.filt.blastp",
        sample_chrom  = lambda wildcards: config["species"][wildcards.sample]["chrom"],
        coloredby_rbh = lambda wildcards: os.path.join(colors_path, "{}.rbh".format(wildcards.coloredby))
    output:
        rbh = config["tool"] + "/step1-rbh/{coloredby}_{sample}_reciprocal_best_hits.hmm.rbh"
    threads: 1
    run:
        # final columns must be
        columns = ["rbh", "gene_group",
                   "{}_gene".format(wildcards.coloredby),
                   "{}_scaf".format(wildcards.coloredby),
                   "{}_pos".format( wildcards.coloredby),
                   "{}_gene".format(wildcards.sample),
                   "{}_scaf".format(wildcards.sample),
                   "{}_pos".format( wildcards.sample),
                   "{}_breakchrom".format( wildcards.coloredby),
                   "{}_breakchrom".format( wildcards.sample),
                   "{}_ix".format( wildcards.coloredby),
                   "{}_ix".format( wildcards.sample),
                   "{}_break_ix".format( wildcards.coloredby),
                   "{}_break_ix".format( wildcards.sample)]

        # read in a tsv of the input blastp file
        df = pd.read_csv(input.hmm, sep = "\t", header = None)
        df.columns = ["qseqid", "sseqid", "pident", "length", "mismatch", "gapopen",
                      "qstart", "qend",   "sstart", "send",   "evalue",   "bitscore"]
        # sort by sseqid, evalue, and bitscore. Then drop duplicates and keep only the best hit for each sseqid
        df = df.sort_values(by = ["sseqid", "evalue", "bitscore"], ascending = [True, True, False])
        df = df.drop_duplicates(subset = "sseqid", keep = "first") 
        # sort by qseqid, evalue, and bitscore. Then, drop duplicates and keep only the best hit for each qseqid
        df = df.sort_values(by = ["qseqid", "evalue", "bitscore"], ascending = [True, True, False])
        df = df.drop_duplicates(subset = "qseqid", keep = "first")
        # now just keep the relevant columns
        df = df[["qseqid", "sseqid"]]
        df.columns = ["{}_gene".format(wildcards.coloredby), "{}_gene".format(wildcards.sample)]



        entries = []
        linecounter = 0
        with open(output.rbh, "w") as outhandle:
            with open(input.hmm, "r") as f:
                entry = {k: "" for k in columns} 
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#"):
                        fields = line.split()
                        qseqid = fields[0]
                        sseqid = fields[1]
                        print("\t".join([qseqid, sseqid]), file = outhandle)

# mer_BFL_EMU_HVU_PYE_RES_2626    27724   50.0    50.0    0       0       0       0       0       0       1.5e-48 165.6
# mer_BFL_EMU_HVU_PYE_RES_2626    153089  50.0    50.0    0       0       0       0       0       0       4e-32   111.2
# mer_BFL_EMU_HVU_PYE_RES_2626    87351   50.0    50.0    0       0       0       0       0       0       4.4e-26 91.1
# mer_BFL_EMU_HVU_PYE_RES_2626    149137  50.0    50.0    0       0       0       0       0       0       9.6e-26 90.0
# mer_BFL_EMU_HVU_PYE_RES_2626    110027  50.0    50.0    0       0       0       0       0       0       2e-24   85.7
# mer_BFL_EMU_HVU_PYE_RES_1350    105924  50.0    50.0    0       0       0       0       0       0       4.6e-47 161.3
# mer_BFL_EMU_HVU_PYE_RES_1350    180035  50.0    50.0    0       0       0       0       0       0       1.4e-37 129.9
# mer_BFL_EMU_HVU_PYE_RES_1350    170935  50.0    50.0    0       0       0       0       0       0       2.9e-37 128.8
# mer_BFL_EMU_HVU_PYE_RES_1350    176611  50.0    50.0    0       0       0       0       0       0       1.5e-31 109.9
# mer_BFL_EMU_HVU_PYE_RES_1350    224536  50.0    50.0    0       0       0       0       0       0       3.1e-31 108.9
# mer_BFL_EMU_HVU_PYE_RES_2493    227654  50.0    50.0    0       0       0       0       0       0       1.1e-225        752.2
# mer_BFL_EMU_HVU_PYE_RES_125     149861  50.0    50.0    0       0       0       0       0       0       1.7e-236        785.8
# mer_BFL_EMU_HVU_PYE_RES_125     31909   50.0    50.0    0       0       0       0       0       0       1.4e-23 84.0
# mer_BFL_EMU_HVU_PYE_RES_1014    158712  50.0    50.0    0       0       0       0       0       0       9e-91   305.3

# rbh     CTE_gene        LGI_gene        gene_group      CTE_scaf        CTE_pos LGI_scaf        LGI_pos CTE_breakchrom  LGI_breakchrom  CTE_ix  CTE_break_ix    LGI_ix  LGI_break_ix
# rbh2way_CTE_LGI_758     99454   102840  None    scaffold_1057   38715   sca_1   17673   scaffold_1057:0-end     sca_1:0-end     1       1       0       0
# rbh2way_CTE_LGI_5617    182031  202951  None    scaffold_12     462177  sca_1   27971   scaffold_12:0-end       sca_1:0-end     17      17      1       1
# rbh2way_CTE_LGI_5953    106237  208014  None    scaffold_586    50104   sca_1   73150   scaffold_586:0-end      sca_1:0-end     0       0       2       2
# rbh2way_CTE_LGI_772     226302  103055  None    scaffold_346    31657   sca_1   306387  scaffold_346:0-end      sca_1:0-end     0       0       3       3
# rbh2way_CTE_LGI_87      227767  56504   None    scaffold_722    60567   sca_1   415633  scaffold_722:0-end      sca_1:0-end     0       0       4       4
# rbh2way_CTE_LGI_5954    18454   208023  None    scaffold_24     290037  sca_1   417288  scaffold_24:0-end       sca_1:0-end     9       9       5       5


"""
This makes the synteny plots with the pre-installed color groups
"""
rule plot_synteny_coloredby:
    input:
        rbh = config["tool"] + "/step1-rbh/{analysis}_reciprocal_best_hits.rbh",
        colordir = lambda wildcards: config["prot_to_color"][wildcards.coloredby],
        hmm_results = lambda wildcards: [config["tool"] + "/step0-blastp_results/{}_against_{}.hmmsearch.filt.blastp".format(
            wildcards.coloredby, x) for x in wildcards.analysis.split("_")]
    output:
        rbh = config["tool"] + "/step2-figures/synteny_coloredby_{coloredby}/{analysis}_xy_reciprocal_best_hits.coloredby_{coloredby}.plotted.rbh",
        xy  = config["tool"] + "/step2-figures/synteny_coloredby_{coloredby}/{analysis}_xy_synteny_coloredby_{coloredby}.pdf",
        yx  = config["tool"] + "/step2-figures/synteny_coloredby_{coloredby}/{analysis}_yx_synteny_coloredby_{coloredby}.pdf",
    threads:
        1
    params:
        analysis = lambda wildcards: wildcards.analysis,
        orthology_method = config["diamond_or_blastp"],
        coloredby = lambda wildcards: wildcards.coloredby,
        coloredbydir = lambda wildcards: config["prot_to_color"][wildcards.coloredby]
    run:
        xsample = params.analysis.split("_")[0]
        ysample = params.analysis.split("_")[1]
        xorder  = config["species"][xsample]["plotorder"] if "plotorder" in config["species"][xsample] else []
        yorder  = config["species"][ysample]["plotorder"] if "plotorder" in config["species"][ysample] else []
        xbreaks = config["species"][xsample]["manual_breaks"] if "manual_breaks" in config["species"][xsample] else []
        ybreaks = config["species"][ysample]["manual_breaks"] if "manual_breaks" in config["species"][ysample] else []

        # figure out how to sort the scaffolds
        sort_y_by_x = True
        if "sort_by_x_coord_blast" in config["species"][ysample]:
            sort_y_by_x = config["species"][ysample]["sort_by_x_coord_blast"]
        synteny_plot_sheet(input.rbh, output.rbh, output.xy,
                     xsample, ysample,
                     xorder, yorder,
                     xbreaks, ybreaks,
                     params.orthology_method,
                     sort_y_by_x = sort_y_by_x,
                     prot_to_color_name = params.coloredby,
                     prot_to_color_dir  = params.coloredbydir,
                     prot_to_color_hmm_results = input.hmm_results)
        # check again for sort
        if "sort_by_x_coord_blast" in config["species"][xsample]:
            sort_y_by_x = config["species"][xsample]["sort_by_x_coord_blast"]
        synteny_plot_sheet(input.rbh, output.rbh, output.yx,
                     ysample, xsample,
                     yorder, xorder,
                     ybreaks, xbreaks,
                     params.orthology_method,
                     sort_y_by_x = sort_y_by_x,
                     prot_to_color_name = params.coloredby,
                     prot_to_color_dir  = params.coloredbydir,
                     prot_to_color_hmm_results = input.hmm_results)
