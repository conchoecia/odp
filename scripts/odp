"""
This script performs mutual-best protein diamond BLAST searches,
 then makes synteny plots of those results.
"""
from Bio import SeqIO
from itertools import groupby
import matplotlib
from operator import itemgetter
import pandas as pd
import numpy as np
import statistics
import sys

configfile: "config.yaml"

#make fake breaks
for this_axis in ["xaxisspecies", "yaxisspecies"]:
    if this_axis in config:
        for this_one in config[this_axis]:
            if "breaks" not in config[this_axis][this_one]:
                config[this_axis][this_one]["breaks"] = []

#make a function to add entries into y, if the entry is in x but not yet in y
if "yaxisspecies" not in config:
    config["yaxisspecies"] = {}
for thisx in config["xaxisspecies"]:
    if thisx not in config["yaxisspecies"]:
        config["yaxisspecies"][thisx] = config["xaxisspecies"][thisx]

def flatten(list_of_lists):
    """flatten a list of lists"""
    return [item for sublist in list_of_lists for item in sublist]

def expand_avoid_matching_x_and_y(filestring, xsamples, ysamples):
    """
    this works like snakemake's expand function but does not generate
     files where xsample equals ysample

    outputs a list of files
    """
    outlist = []
    for xsamp in xsamples:
        for ysamp in ysamples:
            if xsamp != ysamp:
                outlist.append(filestring.format(xsamp, ysamp))
    return outlist

def expand_avoid_matching_x_and_y_third(filestring, xsamples, ysamples, third):
    """
    this works like snakemake's expand function but does not generate
     files where xsample equals ysample

    outputs a list of files.

    Note March 20th, 2021 - the "third" aspect is related to coloring by another species
    """
    outlist = []
    for xsamp in xsamples:
        for ysamp in ysamples:
            if xsamp != ysamp:
                for t in third:
                    outlist.append(filestring.format(xsamp, ysamp, t))
    return outlist


rule all:
    input:
        #expand("synteny_analysis/blastp_results/xtoybest/{xsample}_against_{ysample}.blastp",
        #        xsample = config["xaxisspecies"], ysample = config["yaxisspecies"]),
        #expand("synteny_analysis/blastp_results/ytoxbest/{ysample}_against_{xsample}.blastp",
        #        xsample = config["xaxisspecies"], ysample = config["yaxisspecies"])
        #expand("synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp",
        #        xsample = config["xaxisspecies"], ysample = config["yaxisspecies"]),
        #expand("synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
        #       xsample = config["xaxisspecies"]),
        #expand("synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
        #       ysample = config["yaxisspecies"])
        expand_avoid_matching_x_and_y("synteny_analysis/plots/synteny_uncolored/{}_and_{}_synteny.pdf",
                config["xaxisspecies"], config["yaxisspecies"]),
        expand_avoid_matching_x_and_y("synteny_analysis/dvalue_table/{}_and_{}_info.tsv",
                config["xaxisspecies"],  config["yaxisspecies"]),

        # working on plotting for color
        expand("synteny_analysis/prot_to_color/{colorby}_prottocolor.tsv",
               colorby = [x for x in config["xaxisspecies"] if "chrom_to_color" in config["xaxisspecies"][x]]),
        #expand_avoid_matching_x_and_y_third(
        #    "synteny_analysis/plots/synteny_colored_by/{}_and_{}_coloredby_{}_synteny.pdf",
        #    config["xaxisspecies"], config["yaxisspecies"],
        #    [x for x in config["xaxisspecies"] if "chrom_to_color" in config["xaxisspecies"][x]]
        #    ),
        #expand_avoid_matching_x_and_y_third(
        #    "synteny_analysis/plots/synteny_colored_by_no_missing/{}_and_{}_coloredby_{}_synteny.pdf",
        #    config["xaxisspecies"], config["yaxisspecies"],
        #    [x for x in config["xaxisspecies"] if "chrom_to_color" in config["xaxisspecies"][x]]
        #    ),
        # make protein similarity plots
        expand_avoid_matching_x_and_y(
            "synteny_analysis/plots/sample_similarity/{}_and_{}_peridentity_length.pdf",
             config["xaxisspecies"], config["yaxisspecies"]),
        #expand("synteny_analysis/plots/sample_similarity/{xsample}_and_{ysample}_peridentity_length.pdf",
        #        xsample = config["xaxisspecies"], ysample = config["yaxisspecies"]),

        #make the correlation plots
        expand_avoid_matching_x_and_y(
            "synteny_analysis/plots/significance/wholechr/{}_and_{}_fisher.pdf",
             config["xaxisspecies"], config["yaxisspecies"])

def filter_fasta_chrom(chrom_file, input_fasta, output_fasta):
    """
    takes a chrom file, only keeps proteins in input_fasta from chrom file,
     saves those prots to output_fasta
    """
    keep_these = set()
    printed_already = set()
    with open(chrom_file, "r") as f:
        for line in f:
            line = line.strip()
            if line:
                splitd = line.split()
                keep_these.add(splitd[0])
    outhandle = open(output_fasta, "w")
    inhandle =  open(input_fasta, "r")
    for record in SeqIO.parse(inhandle, "fasta"):
        if record.id in keep_these and record.id not in printed_already:
            SeqIO.write(record, outhandle, "fasta")
            printed_already.add(record.id)
    inhandle.close()
    outhandle.close()

rule filter_prots_x:
    """
    Sometimes the prot file with have sequences that are not present in
     the chrom file. Make a prot file of only the proteins in the chrom file.
    """
    input:
        prots = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["proteins"],
        chrom = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["prot_to_loc"]
    output:
        pep = "synteny_analysis/db/xaxis/{xsample}_prots.pep"
    threads: 1
    run:
        filter_fasta_chrom(input.chrom, input.prots, output.pep)

rule filter_prots_y:
    """
    Sometimes the prot file with have sequences that are not present in
     the chrom file. Make a prot file of only the proteins in the chrom file.
    """
    input:
        prots = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["proteins"],
        chrom = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["prot_to_loc"]
    output:
        pep = "synteny_analysis/db/yaxis/{ysample}_prots.pep"
    threads: 1
    run:
        filter_fasta_chrom(input.chrom, input.prots, output.pep)


rule make_diamonddb_x:
    input:
        prots = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["proteins"],
        pep = "synteny_analysis/db/xaxis/{xsample}_prots.pep"
    output:
        dmnd = "synteny_analysis/db/xaxis/dmnd/{xsample}_prots.dmnd"
    threads: workflow.cores - 1
    shell:
        """
        diamond makedb --in {input.pep} --db {output.dmnd}
        """

rule make_diamonddb_y:
    input:
        prots = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["proteins"],
        pep = "synteny_analysis/db/yaxis/{ysample}_prots.pep"
    output:
        dmnd = "synteny_analysis/db/yaxis/dmnd/{ysample}_prots.dmnd"
    threads: workflow.cores - 1
    shell:
        """
        diamond makedb --in {input.pep} --db {output.dmnd}
        """

rule diamond_blast_x_to_y:
    input:
        xpep = "synteny_analysis/db/xaxis/{xsample}_prots.pep",
        ydmnd = "synteny_analysis/db/yaxis/dmnd/{ysample}_prots.dmnd",
    output:
        blastp = "synteny_analysis/blastp_results/xtoy/{xsample}_against_{ysample}.blastp",
    threads: workflow.cores - 1
    shell:
        """
        diamond blastp --query {input.xpep} --db {input.ydmnd} \
          --threads {threads} --evalue 1E-5 --outfmt 6 --out {output.blastp}
        """

rule diamond_blast_y_to_x:
    input:
        ypep = "synteny_analysis/db/yaxis/{ysample}_prots.pep",
        xdmnd = "synteny_analysis/db/xaxis/dmnd/{xsample}_prots.dmnd",
    output:
        blastp = "synteny_analysis/blastp_results/ytox/{ysample}_against_{xsample}.blastp",
    threads: workflow.cores - 1
    shell:
        """
        diamond blastp --query {input.ypep} --db {input.xdmnd} \
          --threads {threads} --evalue 1E-5 --outfmt 6 --out {output.blastp}
        """

rule absolute_best_from_blast_x_to_y:
    input:
        blastp = "synteny_analysis/blastp_results/xtoy/{xsample}_against_{ysample}.blastp",
    output:
        blastp = "synteny_analysis/blastp_results/xtoybest/{xsample}_against_{ysample}.blastp",
    threads: 1
    shell:
        """
        awk 'BEGIN{{former = ""}} {{if ($1 != former){{print($0)}}; former=$1}}' {input.blastp} > {output.blastp}
        """

rule absolute_best_from_blast_y_to_x:
    input:
        blastp = "synteny_analysis/blastp_results/ytox/{ysample}_against_{xsample}.blastp",
    output:
        blastp = "synteny_analysis/blastp_results/ytoxbest/{ysample}_against_{xsample}.blastp",
    threads: 1
    shell:
        """
        awk 'BEGIN{{former = ""}} {{if ($1 != former){{print($0)}}; former=$1}}' {input.blastp} > {output.blastp}
        """

rule reciprocal_best_hits:
    """
    finds the reciprocal best hits.
    reports it in the form of the blastp results from x -> y search
    """
    input:
        ytoxblastp = "synteny_analysis/blastp_results/ytoxbest/{ysample}_against_{xsample}.blastp",
        xtoyblastp = "synteny_analysis/blastp_results/xtoybest/{xsample}_against_{ysample}.blastp",
    output:
        xtoyblastp = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp",
    threads: 1
    run:
        pairs = set()
        #first look in y_to_x
        with open(input.ytoxblastp, "r") as f:
            for line in f:
                line = line.strip()
                if line:
                    splitd = line.split("\t")
                    add_this = (splitd[1], splitd[0])
                    if add_this in pairs:
                        raise IOError("This set was already found")
                    else:
                        pairs.add(add_this)
        # now go through x_to_y and filter
        out_handle = open(output.xtoyblastp, "w")
        with open(input.xtoyblastp, "r") as f:
            for line in f:
                line = line.strip()
                if line:
                    splitd = line.split("\t")
                    check_this = (splitd[0], splitd[1])
                    if check_this in pairs:
                        print(line, file=out_handle)
        out_handle.close()

rule make_recip_table_for_marginplot:
    input:
        xtoyblastp = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp",
    output:
        table = "synteny_analysis/blastp_results/reciprocal_best/table_for_marginplot/{xsample}_and_{ysample}_peridentity_length.tsv",
    threads: 1
    shell:
        """
        echo "" | awk '{{printf("PercentIdentity\\tMatchLength\\n")}}' > {output.table}
        cat {input.xtoyblastp} | cut -f3,4 >> {output.table}
        """

rule make_identity_marginplot:
    input:
        table = "synteny_analysis/blastp_results/reciprocal_best/table_for_marginplot/{xsample}_and_{ysample}_peridentity_length.tsv",
    output:
        plot = "synteny_analysis/plots/sample_similarity/{xsample}_and_{ysample}_peridentity_length.pdf"
    params:
        stem = "synteny_analysis/plots/sample_similarity/{xsample}_and_{ysample}_peridentity_length",
        xsample = lambda wildcards: wildcards.xsample,
        ysample = lambda wildcards: wildcards.ysample
    threads: 1
    shell:
        """
        pauvre custommargin -i {input.table} --fileform pdf \
          --xcol MatchLength --ycol PercentIdentity \
          -o {params.stem} --no_timestamp \
          --plot_min_y 0 --plot_max_y 100 \
          --plot_min_x 0 --plot_max_x 2000 \
          -t "Protein Identity of {params.xsample} and {params.ysample}"
        """

rule get_genome_coords_x:
    input:
        genome = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["genome"]
    output:
        coords = "synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
    threads:
        1
    params:
        minsize = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["minscafsize"]
    shell:
        """
        bioawk -cfastx '{{ if (length($seq) >= {params.minsize}) {{ \
                           print($name, length($seq), sum)  }} \
                        }}' {input.genome} | \
          sort -k2 -nr | \
          awk '{{sum = sum + $2; print($1, $2, sum) }}' > {output.coords}
        """

rule get_genome_coords_y:
    input:
        genome = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["genome"]
    output:
        coords = "synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
    threads:
        1
    params:
        minsize = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["minscafsize"]
    shell:
        """
        bioawk -cfastx '{{ if (length($seq) >= {params.minsize}) {{ \
                           print($name, length($seq), sum)  }} \
                        }}' {input.genome} | \
          sort -k2 -nr | \
          awk '{{sum = sum + $2; print($1, $2, sum) }}' > {output.coords}
        """

def generate_coord_structs(prot_to_loc_file):
    """
    This parses a .chrom file and outputs five data structures that are easily
     used for mapping pandas dataframes.
    The output is a dict of dicts. Not the most intuitive format but easy for
     mapping to column values.
     { "prot_to_scaf":   prot_to_scaf,
       "prot_to_strand": prot_to_strand,
       "prot_to_start":  prot_to_start,
       "prot_to_stop":   prot_to_stop,
       "prot_to_middle": prot_to_middle }
    """
    prot_to_scaf   = {}
    prot_to_strand = {}
    prot_to_start  = {}
    prot_to_stop   = {}
    prot_to_middle = {}
    with open(prot_to_loc_file, "r") as f:
       for line in f:
           line = line.strip()
           if line:
               splitd = line.split()
               prot = splitd[0]
               # add things now
               prot_to_scaf[prot]   = splitd[1]
               prot_to_strand[prot] = splitd[2]
               start = int(splitd[3])
               prot_to_start[prot]  = start
               stop = int(splitd[4])
               prot_to_stop[prot]   = stop
               stop = int(splitd[4])
               prot_to_middle[prot] = int(start + (stop - start)/2)
    return { "prot_to_scaf":   prot_to_scaf,
             "prot_to_strand": prot_to_strand,
             "prot_to_start":  prot_to_start,
             "prot_to_stop":   prot_to_stop,
             "prot_to_middle": prot_to_middle }

def blast_plot_order_helper(coords, sample, xory, xprottoloc, yprottoloc, recip, xorder):
    """
    This uses the reciprocal blast results to come up with the sort order
     for the y-axis scaffolds. Returns a list of the plot order.

    This code is all duplicated from the synteny plot function.
     Could be programmed in a better way to avoid redundancy, but this just fits
     the edge case where the y-axis has to be arranged based on the blast results.
    """
    # now make a lookup table of where the prots are.
    #  Use the x_offset and y_offset to recalculate where the plotting
    #  value is
    xcoords = generate_coord_structs(xprottoloc)
    ycoords = generate_coord_structs(yprottoloc)

    # now open the blast results and translate the pairs
    #  into plotting positions
    df = pd.read_csv(recip, header=None, sep = "\t")
    df.columns = ["xgene", "ygene", "pident", "length",
                  "mismatch", "gapopen", "qstart", "qend",
                  "sstart", "send", "evalue", "bitscore"]
    df = df[["xgene", "ygene", "bitscore", "evalue"]]

    #print(x_prot_to_loc)
    df["xpos"] = df["xgene"].map(xcoords["prot_to_middle"])
    df["ypos"] = df["ygene"].map(ycoords["prot_to_middle"])

    df["xscaf"] = df["xgene"].map(xcoords["prot_to_scaf"])
    df["yscaf"] = df["ygene"].map(xcoords["prot_to_scaf"])
    df = df.dropna()
    df = df.sort_values(by=['xpos'])
    df = df.loc[df["evalue"] <= float("1E-20"), ]
    df = df.dropna()

    grouped_df = df.groupby(["yscaf"])
    for key, item in grouped_df:
        max_item = grouped_df.get_group(key)['xscaf'].value_counts().idxmax()
        all_other_things = [x for x in grouped_df.get_group(key)['xscaf'].unique() if x != max_item]
        for thisthing in all_other_things:
            df = df.loc[~( (df["yscaf"] == key) & (df["xscaf"] == thisthing)), ]
    # now sort based on the xscafs and the xpos
    sorterIndex = dict(zip(xorder, range(len(xorder))))
    df.sort_values(['yscaf', 'ypos'],
        ascending = [True, True], inplace = True)
    df.reset_index(drop=True, inplace = True)
    df = df.drop_duplicates(subset=['yscaf'])
    df['x_Rank'] = df['xscaf'].map(sorterIndex)
    df.sort_values(['x_Rank', 'xpos'],
        ascending = [True, True], inplace = True)
    df = df.dropna()
    df.reset_index(drop=True, inplace = True)
    print(df)
    #print(list(df.yscaf))
    return(list(df.yscaf))

def parse_coords(coords, sample, xory,
                 xprottoloc=None, yprottoloc=None,
                 recip=None, xorder=None):
    """
    This parses the coordinates and returns a
      - coord-to-offset dict (I don't remember what this is for),
      - the size of each scaffold (a dictionary)
      - a list of locations to plot lines (These are the scaf/chrom divisions)
      - the max value for that axis
      - the tick labels
      - the tick positions
      - the yorder or xorder
    """
    offset = {}
    max_coord = 0
    lines_at = []
    df = pd.read_csv(coords, header = None, sep = " ")
    df.columns = ["scaf", "scaflen", "cumsum"]
    # now figure out if we need to sort or not
    drop_nas = True
    # make sure that plotorder and sort_by_x_coord_blast aren't there together
    #  These are two conflicting sort order operations.
    #  Specifically, sort_by_x_coord_blast will mess up plotorder.
    if ("plotorder" in config["{}axisspecies".format(xory)][sample]) and \
       ("sort_by_x_coord_blast" in config["{}axisspecies".format(xory)][sample]):
        raise IOError("""can't have plotorder and sort_by_x_coord_blast in the
        same sample.""")

    if xory == "x":
        if sample not in config["xaxisspecies"]:
            raise IOError("Can't find this xspecies")
        else:
            if "plotorder" in config["xaxisspecies"][sample]:
                plotorder = config["xaxisspecies"][sample]["plotorder"]
                #print("plot order is: {}".format(plotorder))
                drop_nas = False
            else:
                plotorder = None
    elif xory == "y":
        #print("we're in y")
        if sample not in config["yaxisspecies"]:
            raise IOError("Can't find this yspecies")
        else:
            #print("we're in the else of y")
            if "plotorder" in config["yaxisspecies"][sample]:
                #print("we're in the plotorder of y")
                plotorder = config["yaxisspecies"][sample]["plotorder"]
                #print("plotorder zeroth " + plotorder[0])
                drop_nas = False
            elif "sort_by_x_coord_blast" in config["yaxisspecies"][sample]:
                #print("we're in the sort_by_x_coord_blast of y")
                if config["yaxisspecies"][sample]["sort_by_x_coord_blast"]:
                    #print("we're in the sort_by_x_coord_blast of y True")
                    # we need to set up the sort order based on the occurrence in the blast results
                    plotorder = blast_plot_order_helper(coords, sample, xory,
                                                        xprottoloc, yprottoloc,
                                                        recip, xorder)
                    #print("after plot order in sort_by_x_coord_blast")
            else:
                #print("in the else")
                plotorder = None
    else:
        raise IOError("Don't know what this is")
    #print("df after xory")
    # now we have determined if we need to sort
    if plotorder != None: # if plotorder has something in it.
        #print(" - using custom plot order: ", plotorder)
        sortdict = {key: val for key, val in zip(plotorder, range(len(plotorder)))}
        df['rank'] = df['scaf'].map(sortdict)
        df.sort_values(by = 'rank' ,inplace=True)
    #print("df after plotorder")
    #print(df)

    # now, if we made plotorder from config then drop rows
    if "plotorder" in config["{}axisspecies".format(xory)][sample]:
        df = df[df["scaf"].isin(config["{}axisspecies".format(xory)][sample]["plotorder"])]
    # only drop if we haven't specified the plot order in the config
    #if drop_nas:
    #    df = df.dropna()
    df.reset_index(drop=True, inplace = True)
    df["cumsum"] = df["scaflen"].cumsum()
    df["cumsum"] = df["cumsum"] - df["scaflen"]
    print("df after cumulative sum and sorting")
    print(df)
    for i, row in df.iterrows():
        offset[row["scaf"]] = row["cumsum"]
        if i > 0:
            lines_at.append(row["cumsum"])
    max_coord = list(df["scaflen"].cumsum())[-1]

    #tick labels
    tick_labels = list(df["scaf"])
    tick_pos    = list(df["cumsum"] + (df["scaflen"]/2))

    scaf_to_len = {}
    for i, row in df.iterrows():
        scaf_to_len[row["scaf"]] = row["scaflen"]

    return (offset, scaf_to_len, lines_at, max_coord, tick_labels, tick_pos, list(df["scaf"]))


def calc_D_for_y_and_x(df, x_offset, y_offset, x_scaf_to_len, y_scaf_to_len):
    """
    This calculates D for both the x and y axes.
    Defined in the 2020 vertebrate synteny paper.
    """
    df = df.dropna()
    # some variable names in this for loop are "x" but it doesn't matter.
    #  everything important is variable between x and y
    for thisdir in ["x", "y"]:
        df = df.sort_values(by=["{}middle".format(thisdir)])
        df.reset_index(drop=True, inplace = True)

        unique_x = df["{}scaf".format(thisdir)].unique()
        thisdir_dfs = []
        # this just calculates Dx
        for thisx in unique_x:
            xdf = df.loc[df["{}scaf".format(thisdir)] == thisx, ].copy()
            xdf = xdf.reset_index(drop=True)
            oppositexy = "d"
            this_offset = {}
            this_scaf_to_len = {}
            if thisdir == "x":
                oppositexy = "y"
                this_offset = x_offset
                this_scaf_to_len = x_scaf_to_len
            elif thisdir == "y":
                oppositexy = "x"
                this_offset = y_offset
                this_scaf_to_len = y_scaf_to_len
            df2 = pd.get_dummies(xdf["{}scaf".format(oppositexy)])
            df2_xiL = df2.apply(lambda x: x.rolling(20).mean(), axis = 0)
            df2_xiR = df2.apply(lambda x: x.iloc[::-1].rolling(20).mean(), axis = 0).iloc[::-1]
            df2_xiR = df2_xiR.set_index(df2_xiR.index - 1)
            df2_xiR = df2_xiR.iloc[1:]
            subtractdf = df2_xiR.fillna(0) - df2_xiL.fillna(0)
            D = subtractdf.apply(lambda x: np.sqrt(np.square(x).sum()), axis = 1)
            xdf["D{}".format(thisdir)] = D
            xdf["D{}_barleft".format(thisdir)] = 0
            xdf["D{}_barmiddle".format(thisdir)] = 0
            xdf["D{}_barright".format(thisdir)] = 0
            xdf["D{}_barwidth".format(thisdir)] = 0
            for i, row in xdf.iterrows():
                barleft   = -1
                barright  = -1
                barmiddle = -1
                barwidth  = -1
                if i == 0:
                    thisend   = row["{}stop".format(thisdir)]
                    nextstart = xdf.loc[i+1, "{}start".format(thisdir)]
                    barleft   = this_offset[thisx]
                    barright  = thisend + ((nextstart-thisend)/2)
                elif i == (len(xdf) - 1):
                    prevend   = xdf.loc[i-1, "{}stop".format(thisdir)]
                    thisstart = row["{}start".format(thisdir)]
                    barleft   = prevend + ((thisstart-prevend)/2)
                    barright  = this_scaf_to_len[thisx]
                else:
                    prevend   = xdf.loc[i-1, "{}stop".format(thisdir)]
                    thisstart = row["{}start".format(thisdir)]
                    thisend   = row["{}stop".format(thisdir)]
                    nextstart = xdf.loc[i+1, "{}start".format(thisdir)]
                    barleft   = prevend + ((thisstart-prevend)/2)
                    barright  = thisend + ((nextstart-thisend)/2)
                xdf.loc[i, "D{}_barleft".format(thisdir)]   = barleft
                xdf.loc[i, "D{}_barright".format(thisdir)]  = barright
                xdf.loc[i, "D{}_barmiddle".format(thisdir)] = barleft + ((barright - barleft)/2)
                xdf.loc[i, "D{}_barwidth".format(thisdir)]  = barright - barleft + 1
            thisdir_dfs.append(xdf)
        df = pd.concat(thisdir_dfs)
    df = df.sort_values(by=["xmiddle"])
    df.reset_index(drop=True, inplace = True)
    return df

def determine_breaks(df, sort_direction):
    """
    determines the major breaks in Dx or Dy to use as partitions.

    The input parameters are:
      - df: the analysis df at the end of synteny plot.
      - sort_direction: either "x" or "y"
    """
    # MAGIC NUMBERS
    # set window to change how many genes on either side are considered when
    #  looking for peaks. A value of 20 means 20 on either side, so 41 genes total
    window = 20
    smallwindow = 5
    # set small_window to resolve nearby peaks from different datasources

    sort_order = {"x": {"pos": "xmiddle",
                        "chrom": "xscaf",
                        "D": "Dx"},
                  "y": {"pos": "ymiddle",
                        "chrom": "yscaf",
                        "D": "Dy"}}

    # sort the dataframe based on which axis we're looking at
    df = df.sort_values(by=[sort_order[sort_direction]["pos"]])
    df = df.reset_index(drop=True)

    unique_chroms = []
    #chrom_breakpoints = []
    for index, row in df.iterrows():
        thischrom = row[sort_order[sort_direction]["chrom"]]
        thispos  = row[sort_order[sort_direction]["pos"]]
        if thischrom not in unique_chroms:
            unique_chroms.append(thischrom)
            #chrom_breakpoints.append(thispos)
    ## this line is solely for plotting. Not useful
    #chrom_breakpoints = chrom_breakpoints[1::]

    # There are three different analysis types that we will use to figure
    #  out the seps.
    # - deltMA is the derivative of the smoothed data
    # - deltD is the derivative of the raw data
    # - Dx2 is the raw D data.
    #
    # All of the data are selected based on the max value of what was above
    #  the median for that chromosome.
    all_ranges = set()
    for thiscol in ["MA", "deltMA","deltD", "Dx2"]:
        for thischrom in unique_chroms:
            # use .copy() to make sure we're not modifying the original df
            subdf = df.loc[df[sort_order[sort_direction]["chrom"]] == thischrom, ].copy()
            # Dx2 is just the raw data that is above the median
            subdf["Dx2"] = subdf[sort_order[sort_direction]["D"]]
            subdf['Dx2'] = np.where((subdf[sort_order[sort_direction]["D"]] < subdf[sort_order[sort_direction]["D"]].median()),np.NaN,subdf["Dx2"])
            # MA is the moving average of the raw data
            subdf["MA"] = subdf["Dx2"].rolling(window=3, center=True).mean()
            subdf["MA2"] = subdf["Dx2"].rolling(window=19, center=True).mean()
            # deltMA is the derivative of the moving average
            subdf["deltMA"] = subdf["MA"].diff() / subdf["MA"].index.to_series().diff()
            subdf['deltMA'] = np.where((subdf["MA"] < subdf["MA"].median()),np.NaN,subdf["deltMA"])
            # deltD is the derivative of the raw data
            subdf["deltD"] = subdf["Dx2"].diff() / subdf["Dx2"].index.to_series().diff()
            subdf['deltD'] = np.where((subdf.Dx2 < subdf["Dx2"].median()),np.NaN,subdf.deltD)

            # get the groups of consecutive values in each category
            idxmaxes = set()
            ind = list(subdf[~subdf[thiscol].isnull()].index)
            ranges =[]
            for k,g in groupby(enumerate(ind),lambda x:x[0]-x[1]):
                group = (map(itemgetter(1),g))
                group = list(map(int,group))
                ranges.append((group[0],group[-1]))

            # now get the peak from each contiguous range of values
            if len(ranges) > 0:
                for this_range in ranges:
                    if this_range[0] != this_range[-1]:
                        #this_range = [x for x in range(this_range[0], this_range[1]+1)]
                        this_range = list(this_range)
                        which_d_col = sort_order[sort_direction]["D"]
                        temp = subdf.loc[this_range[0]:this_range[-1]][which_d_col].idxmax()
                        idxmaxes.add(temp)

            # picks the best in large windows of genes.
            #  See the description for the 'window' variable above
            keep_idx_maxes = set()
            ignore_set = set()
            done = False
            consider_ranges = set()
            while not done:
                consider_ranges = set()
                # get peaks within the window if they're not in the ignore set
                for this_idx in idxmaxes:
                    thistup = tuple([x for x in idxmaxes
                         if ((x > this_idx - window)
                             and (x < this_idx + window)
                             and (x not in ignore_set))])
                    if len(thistup) > 0:
                        consider_ranges.add(thistup)

                # now for each set of peaks, get the best in each window
                consider_ranges = sorted(list(consider_ranges), key=len, reverse=True)
                if len(consider_ranges) > 0: # skip the empty ranges
                    thisrange = list(consider_ranges[0])
                    if len(thisrange) == 1:
                        done = True
                    else:
                        submax = df.loc[thisrange, ][sort_order[sort_direction]["D"]].idxmax()
                        for thisid in thisrange:
                            if thisid != submax:
                                ignore_set.add(thisid)
                else: # if it is empty, leave
                    done = True
            # We found the biggest peaks in the windows, add them to all_ranges
            for entry in consider_ranges:
                all_ranges.add(entry)

    # flatten the results of what we got from the last analysis
    idxmaxes = flatten(all_ranges)

    # From the dataset of all peaks, find the best in small windows.
    #  See the variable `smallwindow` above
    # The reason we have this block is that the same peak, or something near it,
    #  could have been added multiple times, at slightly different indices.
    #  This collapses the similar indices to get the best.
    ignore_set = set()
    done = False
    consider_ranges = set()
    while not done:
        consider_ranges = set()
        for this_idx in idxmaxes:
            # get windows of ranges if they're not in the ignore set
            thistup = tuple([x for x in idxmaxes
                 if ((x > this_idx - smallwindow)
                     and (x < this_idx + smallwindow)
                     and (x not in ignore_set))])
            if len(thistup) > 0:
                consider_ranges.add(thistup)

        consider_ranges = sorted(list(consider_ranges), key=len, reverse=True)
        if len(consider_ranges) > 0:
            thisrange = list(consider_ranges[0])
            if len(thisrange) == 1:
                done = True
            else:
                submax = df.loc[thisrange, ][sort_order[sort_direction]["D"]].idxmax()
                for thisid in thisrange:
                    if thisid != submax:
                        ignore_set.add(thisid)
        else:
            # there's nothing here
            done = True

    # vert_lines is the list of indices from the df that have the peaks that
    #  we want to keep.
    vert_lines = flatten(consider_ranges)
    # return a dataframe of the intersections we want
    return df.loc[vert_lines].copy()

def gen_plotting_df(ycoords, xcoords,
                    xprottoloc, yprottoloc,
                    xsample, ysample,
                    recip, outtable, plotorder_file):
    """
    Generates a dataframe that will be used by the other parts of the program
     for plotting.
    Saves it to a file
    """
    import pandas as pd
    import numpy as np
    # set seaborn stuff

    # first make a lookup table of how to calculate the
    #  x and y coords. This lookup is just the amount of
    # bp to add to the value when plotting. We pass the xprot_to_loc,
    #  xprot_to_scaf in case we need to sort everything based on order of
    #  occurrence on the scaffolds
    x_offset, x_scaf_to_len, vertical_lines_at, xmax, xticklabel, xtickpos, xorder = parse_coords(
        xcoords, xsample, "x")
    print("found {} x chromosomes".format(len(x_offset)))

    y_offset, y_scaf_to_len, horizontal_lines_at, ymax, yticklabel, ytickpos, yorder = parse_coords(
        ycoords, ysample, "y",
        xprottoloc, yprottoloc, recip, xticklabel)
    print("found {} y chromosomes".format(len(y_offset)))

    # now save the plot order to a file
    with open(plotorder_file, "w") as f:
        print("xplotorder:", file=f)
        for entry in xorder:
            print("  - {}".format(entry), file=f)
        print("yplotorder:", file=f)
        for entry in yorder:
            print("  - {}".format(entry), file=f)

    # now make a lookup table of where the prots are.
    #  Use the x_offset and y_offset to recalculate where the plotting
    #  value is
    xstruct = generate_coord_structs(xprottoloc)
    xstruct["prot_plot_start"] = {}
    xstruct["prot_plot_middle"] = {}
    xstruct["prot_plot_stop"] = {}
    ystruct = generate_coord_structs(yprottoloc)
    ystruct["prot_plot_start"] = {}
    ystruct["prot_plot_middle"] = {}
    ystruct["prot_plot_stop"] = {}
    # get rid of proteins that we don't need along the x axis
    #  also set the plotting position based on the offset
    for prot in list(xstruct["prot_to_middle"].keys()):
        scaf = xstruct["prot_to_scaf"][prot]
        if scaf not in x_offset:
            for thisdict in xstruct:
                xstruct[thisdict].pop(prot, None)
        else:
            xstruct["prot_plot_start"][prot]  = xstruct["prot_to_start"][prot] + x_offset[scaf]
            xstruct["prot_plot_middle"][prot] = xstruct["prot_to_middle"][prot] + x_offset[scaf]
            xstruct["prot_plot_stop"][prot]   = xstruct["prot_to_stop"][prot] + x_offset[scaf]
    # get rid of proteins that we don't need along the y axis
    #  also set the plotting position based on the offset
    for prot in list(ystruct["prot_to_middle"].keys()):
        scaf = ystruct["prot_to_scaf"][prot]
        if scaf not in y_offset:
            for thisdict in xstruct:
                ystruct[thisdict].pop(prot, None)
        else:
            ystruct["prot_plot_start"][prot]  = ystruct["prot_to_start"][prot] + y_offset[scaf]
            ystruct["prot_plot_middle"][prot] = ystruct["prot_to_middle"][prot] + y_offset[scaf]
            ystruct["prot_plot_stop"][prot]   = ystruct["prot_to_stop"][prot] + y_offset[scaf]

    # now open the blast results and translate the pairs
    #  into plotting positions
    df = pd.read_csv(recip, header=None, sep = "\t")
    df.columns = ["xgene", "ygene", "pident", "length",
                  "mismatch", "gapopen", "qstart", "qend",
                  "sstart", "send", "evalue", "bitscore"]
    df = df[["xgene", "ygene", "bitscore", "evalue"]]
    #print(x_prot_to_loc)
    df["xstart"]  = df["xgene"].map(xstruct["prot_plot_start"])
    df["xmiddle"] = df["xgene"].map(xstruct["prot_plot_middle"])
    df["xstop"]   = df["xgene"].map(xstruct["prot_plot_stop"])

    df["ystart"]  = df["ygene"].map(ystruct["prot_plot_start"])
    df["ymiddle"] = df["ygene"].map(ystruct["prot_plot_middle"])
    df["ystop"]   = df["ygene"].map(ystruct["prot_plot_stop"])
    print(df)

    # I don't remember why the x and y is switched here.
    df["yscaf"] = df["ygene"].map(ystruct["prot_to_scaf"])
    df["xscaf"] = df["xgene"].map(xstruct["prot_to_scaf"])
    #df = df.dropna() # this messed up plotting order if there were no hits on that scaf.
    df = df.sort_values(by=['xmiddle'])
    df = df.loc[df["evalue"] <= float("1E-20"), ]
    df.reset_index(drop=True, inplace = True)

    # Now calculate D and Dw for both X and Y axes
    df = calc_D_for_y_and_x(df, x_offset, y_offset, x_scaf_to_len, y_scaf_to_len)
    if outtable:
        df.to_csv(outtable, sep="\t")

rule generate_plotting_df_and_plot_order:
    """
    This parses all of the various types of input and generates the df that
     contains the plotting information like genes, reciprocal-best orthologs.

    Also outputs a file of the plotting order.
    """
    input:
        ycoords = "synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
        xcoords = "synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
        xprottoloc = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["prot_to_loc"],
        yprottoloc = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["prot_to_loc"],
        recip = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp"
    output:
        table = "synteny_analysis/dvalue_table/{xsample}_and_{ysample}_info.tsv",
        plot_order = "synteny_analysis/plot_order/{xsample}_and_{ysample}_plotorder.tsv",
    threads:
        1
    params:
        xsample  = lambda wildcards: wildcards.xsample,
        ysample  = lambda wildcards: wildcards.ysample,
    run:
        print("printing x")
        print(config["xaxisspecies"][wildcards.xsample])
        gen_plotting_df(input.ycoords, input.xcoords,
                     input.xprottoloc, input.yprottoloc,
                     params.xsample, params.ysample,
                     input.recip, output.table,
                     output.plot_order)

def synteny_plot(ycoords, xcoords, xprottoloc, yprottoloc, xsample, ysample,
                 xbreaks, ybreaks, recip, synplot, outtable, plotorder_file,
                 prot_to_color, dropmissing,
                 plot_x_lines = False, plot_y_lines = False,
                 auto_determine_x_breaks = False, auto_determine_y_breaks = False):
    """
    If the user provided a plot order, then we should not skip any scaffolds.

    This is the main plotting script for the synteny plot
    """
    import pandas as pd
    import seaborn as sns; sns.set()
    import matplotlib
    import matplotlib.pyplot as plt
    import matplotlib.ticker as ticker
    import matplotlib.patches as mplpatches
    from matplotlib.ticker import StrMethodFormatter, NullFormatter
    import numpy as np
    # set seaborn stuff
    #sns.set(rc={'text.usetex' : True})
    sns.set_style("ticks", {'font.family': ['sans-serif'],
                                'font.sans-serif': ['Helvetica'],
                                'grid.color': '.95'})
    # Preserve the vertical order of embedded images:
    matplotlib.rcParams['image.composite_image'] = False
    # text as font in pdf
    matplotlib.rcParams['pdf.fonttype'] = 42
    matplotlib.rcParams['ps.fonttype'] = 42

    # parse the xbreaks and the ybreaks.
    # These are where there are low-opacity,
    #  dotted lines to show breaks in synteny
    # example entries are like this:
    #"CM022887.1_chromosome_2:4392062"
    #"CM022887.1_chromosome_2:8784125"

    xbreaks_list = []
    for thisx in xbreaks:
        scaf = thisx.split(":")[0]
        pos  = int(thisx.split(":")[1])
        xbreaks_list.append([scaf, pos])
    ybreaks_list = []
    for thisy in ybreaks:
        scaf = thisy.split(":")[0]
        pos  = int(thisy.split(":")[1])
        ybreaks_list.append([scaf, pos])

    # first make a lookup table of how to calculate the
    #  x and y coords. This lookup is just the amount of
    # bp to add to the value when plotting. We pass the xprot_to_loc,
    #  xprot_to_scaf in case we need to sort everything based on order of
    #  occurrence on the scaffolds
    x_offset, x_scaf_to_len, vertical_lines_at, xmax, xticklabel, xtickpos, xorder = parse_coords(
        xcoords, xsample, "x")
    print("found {} x chromosomes".format(len(x_offset)))

    y_offset, y_scaf_to_len, horizontal_lines_at, ymax, yticklabel, ytickpos, yorder = parse_coords(
        ycoords, ysample, "y",
        xprottoloc, yprottoloc, recip, xticklabel)
    print("found {} y chromosomes".format(len(y_offset)))

    # now save the plot order to a file
    with open(plotorder_file, "w") as f:
        print("xplotorder:", file=f)
        for entry in xorder:
            print("  - {}".format(entry), file=f)
        print("yplotorder:", file=f)
        for entry in yorder:
            print("  - {}".format(entry), file=f)

    # now make a lookup table of where the prots are.
    #  Use the x_offset and y_offset to recalculate where the plotting
    #  value is

    xstruct = generate_coord_structs(xprottoloc)
    xstruct["prot_plot_start"] = {}
    xstruct["prot_plot_middle"] = {}
    xstruct["prot_plot_stop"] = {}
    ystruct = generate_coord_structs(yprottoloc)
    ystruct["prot_plot_start"] = {}
    ystruct["prot_plot_middle"] = {}
    ystruct["prot_plot_stop"] = {}
    # get rid of proteins that we don't need along the x axis
    #  also set the plotting position based on the offset
    for prot in list(xstruct["prot_to_middle"].keys()):
        scaf = xstruct["prot_to_scaf"][prot]
        if scaf not in x_offset:
            for thisdict in xstruct:
                xstruct[thisdict].pop(prot, None)
        else:
            xstruct["prot_plot_start"][prot]  = xstruct["prot_to_start"][prot] + x_offset[scaf]
            xstruct["prot_plot_middle"][prot] = xstruct["prot_to_middle"][prot] + x_offset[scaf]
            xstruct["prot_plot_stop"][prot]   = xstruct["prot_to_stop"][prot] + x_offset[scaf]
    # get rid of proteins that we don't need along the y axis
    #  also set the plotting position based on the offset
    for prot in list(ystruct["prot_to_middle"].keys()):
        scaf = ystruct["prot_to_scaf"][prot]
        if scaf not in y_offset:
            for thisdict in xstruct:
                ystruct[thisdict].pop(prot, None)
        else:
            ystruct["prot_plot_start"][prot]  = ystruct["prot_to_start"][prot] + y_offset[scaf]
            ystruct["prot_plot_middle"][prot] = ystruct["prot_to_middle"][prot] + y_offset[scaf]
            ystruct["prot_plot_stop"][prot]   = ystruct["prot_to_stop"][prot] + y_offset[scaf]

    # now open the blast results and translate the pairs
    #  into plotting positions
    df = pd.read_csv(recip, header=None, sep = "\t")
    df.columns = ["xgene", "ygene", "pident", "length",
                  "mismatch", "gapopen", "qstart", "qend",
                  "sstart", "send", "evalue", "bitscore"]
    df = df[["xgene", "ygene", "bitscore", "evalue"]]
    #print(x_prot_to_loc)
    df["xstart"]  = df["xgene"].map(xstruct["prot_plot_start"])
    df["xmiddle"] = df["xgene"].map(xstruct["prot_plot_middle"])
    df["xstop"]   = df["xgene"].map(xstruct["prot_plot_stop"])

    df["ystart"]  = df["ygene"].map(ystruct["prot_plot_start"])
    df["ymiddle"] = df["ygene"].map(ystruct["prot_plot_middle"])
    df["ystop"]   = df["ygene"].map(ystruct["prot_plot_stop"])
    print(df)

    # I don't remember why the x and y is switched here.
    df["yscaf"] = df["ygene"].map(ystruct["prot_to_scaf"])
    df["xscaf"] = df["xgene"].map(xstruct["prot_to_scaf"])
    #df = df.dropna() # this messed up plotting order if there were no hits on that scaf.
    df = df.sort_values(by=['xmiddle'])
    df = df.loc[df["evalue"] <= float("1E-20"), ]
    df.reset_index(drop=True, inplace = True)

    print(df)
    # Now calculate D and Dw for both X and Y axes
    df = calc_D_for_y_and_x(df, x_offset, y_offset, x_scaf_to_len, y_scaf_to_len)
    print(df)

    xgene = df["xgene"]
    x = df["xmiddle"]
    y = df["ymiddle"]
    bitscore = df["bitscore"]

    print("found {} points to plot".format(len(df["xmiddle"])))
    print("max bitscore: ", max(bitscore))
    bitscore_adjusted = [(x/max(bitscore))*60 for x in bitscore]
    colors = [(0, 0, 1.0, min( 1.0, (x/max(bitscore))*(max(bitscore)/np.mean(bitscore)))) for x in bitscore]
    drops = set()
    if prot_to_color:
        for i in range(len(xgene)):
            alpha = colors[i][3]
            try:
                newcolor = list(matplotlib.colors.to_rgba(prot_to_color[xgene[i]]))
            except:
                print("couldn't find a color for: {}".format(xgene[i]))
                newcolor = [0,0,0,1]
                drops.add(i)
            newcolor[3] = alpha
            colors[i] = newcolor

    if dropmissing:
        vararray = [xgene, x, y, bitscore, bitscore_adjusted, colors]
        for j in range(len(vararray)):
            vararray[j] = [vararray[j][i] for i in range(len(vararray[j])) if i not in drops]
        xgene = vararray[0]
        x     = vararray[1]
        y     = vararray[2]
        bitscore = vararray[3]
        bitscore_adjusted = vararray[4]
        colors = vararray[5]

    # save the output
    if outtable:
        df.to_csv(outtable, sep="\t")

    # now make a scatter plot
    figWidth = 8
    figHeight = 8
    plt.figure(figsize=(figWidth,figHeight))
    #set the panel dimensions
    panelWidth = 4
    panelHeight = 4
    dpanel_width = 0.25
    #find the margins to center the panel in figure
    leftMargin = (figWidth - panelWidth)/2
    bottomMargin = ((figHeight - panelHeight)/2)
    panel1 = plt.axes([leftMargin/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         panelHeight/figHeight])     #height
    panelxd = plt.axes([leftMargin/figWidth, #left
                         (bottomMargin+panelHeight+0.1)/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         dpanel_width/figHeight])     #height
    panelyd = plt.axes([(leftMargin+panelWidth + 0.1)/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         dpanel_width/figWidth,   #width
                         panelHeight/figHeight])     #height
    panel1.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=True,
                        left=False, labelleft=True,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    panelxd.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    panelyd.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    # set the panel linewidth thinner
    for this_panel in [panel1, panelxd, panelyd]:
        for axis in ['top','bottom','left','right']:
            this_panel.spines[axis].set_linewidth(0.5)
    # turn off the axis spines
    for this_panel in [panelxd, panelyd]:
        this_panel.spines['top'].set_visible(False)
        this_panel.spines['right'].set_visible(False)

    panel1.scatter(x, y, color = colors,
                   ec = None, s=6, linewidths = 0)
    # set mins and max
    panel1.set_xlim([0,xmax])
    panel1.set_ylim([0,ymax])
    # set x ticks
    newarr = []
    newarrlabels=[]
    if not plot_x_lines:
        #there are inevitably going to be many scaffolds. We need to subset
        # get a list of evenly spaced indices
        numElems = min(20, len(xtickpos)) # this could break if there are fewer elements
        arr = xtickpos
        idx = np.round(np.linspace(0, len(arr) - 1, numElems)).astype(int)
        newarr       = [arr[i] for i in idx]
        newarrNumScaf     = [i for i in idx]
        # turn on y-axis ticks on the left - plot scaffolds
        panel1.tick_params(bottom=True)
        panel1.set_xticks(newarr)
        panel1.set_xticklabels(newarrNumScaf, fontsize=8, rotation=90)
        panel1.set_xlabel(xsample + " number of scaffolds")
    else:
        newarr = [0] + vertical_lines_at + [xmax]
        panel1.set_xticks(xtickpos)
        panel1.set_xticklabels(xticklabel, fontsize=8, rotation = 90)
        panel1.set_xlabel(xsample + " scaffolds")
    # turn on x-axis ticks on the Dx plot
    newarrlabels = [round(x/1000000, 1) for x in newarr]
    panelxd.tick_params(top=True, labeltop=True)
    panelxd.set_xticks(newarr)
    panelxd.set_xticklabels(newarrlabels, fontsize=8, rotation=90)
    panelxd.xaxis.set_label_position("top")
    panelxd.set_xlabel("Mb")

    # set y ticks
    newarr=[]
    newarrlabels=[]
    if not plot_y_lines:
        #there are inevitably going to be many scaffolds. We need to subset
        # get a list of evenly spaced indices
        numElems = min(20, len(ytickpos))
        arr = ytickpos
        idx = np.round(np.linspace(0, len(arr) - 1, numElems)).astype(int)
        newarr       = [arr[i] for i in idx]
        newarrlabels = [round(arr[i]/1000000, 1) for i in idx]
        newarrNumScaf     = [i for i in idx]
        # turn on y-axis ticks on the left - plot scaffolds
        panel1.tick_params(left=True)
        panel1.set_yticks(newarr)
        panel1.set_yticklabels(newarrNumScaf, fontsize=8)
        panel1.set_ylabel(ysample + " number of scaffolds")
    else:
        newarr = [0] + horizontal_lines_at + [ymax]
        panel1.set_yticks(ytickpos)
        panel1.set_yticklabels(yticklabel, fontsize=8)
        panel1.set_ylabel(ysample + " scaffolds")
    # turn on y-axis ticks on the Dy plot
    newarrlabels = [round(x/1000000, 1) for x in newarr]
    panelyd.tick_params(right=True, labelright=True)
    panelyd.set_yticks(newarr)
    panelyd.set_yticklabels(newarrlabels, fontsize=8)
    panelyd.yaxis.set_label_position("right")
    panelyd.set_ylabel("Mb")

    #print(list(zip(df["xpos"], df["Dx"])))

    # set the x and y labels on Dy and Dx

    #for index, row in df.iterrows():
    #    left   = row["xstart"]
    #    bottom = 0
    #    width  = row["xstart"]
    #    hist_rectangle = mplpatches.Rectangle((left, bottom), width, height,
    #                                          linewidth=l_width,
    #                                          facecolor=f_color,
    #                                          edgecolor=e_color)
    #    panelxd.add_patch(hist_rectangle)
    panelxd.bar(x = df["Dx_barmiddle"], height=df["Dx"], width = df["Dx_barwidth"],
                align = "center", lw=0, color="blue", zorder = 2)
    panelxd.set_xlim([0,xmax])
    panelxd.set_ylabel('Dx', fontsize=10)

    panelyd.barh(y = df["Dy_barmiddle"], width=df["Dy"], height = df["Dy_barwidth"],
                 align = "center", lw=0, color="blue", zorder = 2)
    panelyd.set_ylim([0,ymax])
    panelyd.set_xlabel('Dy', fontsize=10)

    for this_axis in [panel1, panelxd, panelyd]:
        this_axis.xaxis.get_offset_text().set_visible(False)
        this_axis.yaxis.get_offset_text().set_visible(False)

    #plot vertical lines
    if plot_x_lines:
        for value in vertical_lines_at:
            panel1.axvline(x=value, color="black", lw=0.5)
    #plot horizontal lines
    if plot_y_lines:
        for value in horizontal_lines_at:
            panel1.axhline(y=value, color="black", lw=0.5)

    # auto-determine the breaks if we need them
    print("Determining if we need to determine breaks.")
    if auto_determine_x_breaks:
        print("  - Determining the new xbreaks automatically.")
        xdf = determine_breaks(df, "x")
        xbreaks = [x + 10 for x in xdf["xmiddle"]]
    if auto_determine_y_breaks:
        print("  - Determining the new ybreaks automatically.")
        ydf = determine_breaks(df, "y")
        ybreaks = [y + 10 for y in ydf["ymiddle"]]

    # plot vertical BOS
    for value in xbreaks:
        panel1.axvline(x=value, color=[0,0,0,0.25], lw=0.5, linestyle="dotted")
    # plot horizontal BOS
    for value in ybreaks:
        panel1.axhline(y=value, color=[0,0,0,0.25], lw=0.5, linestyle="dotted")
    plt.savefig(synplot)


"""
This makes the synteny plot without doing any special coloring of the dots
"""
rule plot_synteny:
    input:
        table = "synteny_analysis/dvalue_table/{xsample}_and_{ysample}_info.tsv",
        plot_order = "synteny_analysis/plot_order/{xsample}_and_{ysample}_plotorder.tsv",
        ycoords = "synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
        xcoords = "synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
        xprottoloc = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["prot_to_loc"],
        yprottoloc = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["prot_to_loc"],
        recip = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp"
    output:
        synplot = "synteny_analysis/plots/synteny_uncolored/{xsample}_and_{ysample}_synteny.pdf",
        table = "synteny_analysis/dvalue_table/{xsample}_and_{ysample}_info.tsv",
        plot_order = "synteny_analysis/plot_order/basic/{xsample}_and_{ysample}_plotorder.tsv",
    threads:
        1
    params:
        xsample  = lambda wildcards: wildcards.xsample,
        ysample  = lambda wildcards: wildcards.ysample,
        xbreaks  = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["breaks"],
        ybreaks  = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["breaks"],
        keep_x   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["xaxisspecies"][wildcards.xsample]) or ("noxlines" in config["xaxisspecies"][wildcards.xsample])) else True,
        keep_y   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["yaxisspecies"][wildcards.ysample]) or ("noylines" in config["yaxisspecies"][wildcards.ysample])) else True,
        autoxb   = lambda wildcards: True if ( ("auto_d_breaks" in config["xaxisspecies"][wildcards.xsample]) and (config["xaxisspecies"][wildcards.xsample]["auto_d_breaks"] == True)) else False,
        autoyb   = lambda wildcards: True if ( ("auto_d_breaks" in config["yaxisspecies"][wildcards.ysample]) and (config["yaxisspecies"][wildcards.ysample]["auto_d_breaks"] == True)) else False,
    run:
        print("printing x")
        print(config["xaxisspecies"][wildcards.xsample])
        synteny_plot(input.ycoords, input.xcoords,
                     input.xprottoloc, input.yprottoloc,
                     params.xsample, params.ysample,
                     params.xbreaks, params.ybreaks,
                     input.recip, output.synplot, output.table,
                     output.plot_order, None,
                     False,
                     plot_x_lines = params.keep_x,
                     plot_y_lines = params.keep_y,
                     auto_determine_x_breaks = params.autoxb,
                     auto_determine_y_breaks = params.autoyb)

def sizes_and_scale_minp(smallest_p):
    """
    This outputs two lists. One of scale, and one of sizes,
    based on the smallest_p.

    This is used for plotting elipses in the figure and the legend
    """
    scale     = [1,       0.84,     0.67,     0.5,    0.3   ]

    if smallest_p == 0:
        sizes = [0,       "1E-20", "1E-10", "1E-5", "1E-2"]
    elif smallest_p <= float("1E-20"):
        sizes = ["1E-20", "1E-15", "1E-7",  "1E-4", "5E-2"]
    elif smallest_p <= float("1E-15"):
        sizes = ["1E-15", "1E-10", "1E-5",  "1E-2", "1E-1"]
    elif smallest_p <= float("1E-10"):
        sizes = ["1E-10", "1E-7",  "1E-4",  "1E-2", "1E-1"]
    elif smallest_p <= float("1E-8"):
        sizes = ["1E-8",  "1E-6",  "1E-4",  "1E-2", "1E-1"]
    elif smallest_p <= float("1E-6"):
        sizes = ["1E-6",  "1E-5",  "1E-3",  "1E-2", "1E-1"]
    elif smallest_p <= float("1E-5"):
        sizes = ["1E-5",  "1E-4",  "1E-3",  "1E-2", "0.5"]
    else:
        sizes = ["1E-4",  "1E-3",  "1E-2",  "1E-1", "0.5"]
    return [scale, sizes]

def quantize_pvalue(xsize, ysize, p, smallest_p):
    """
    This quantizes the pvalues using standard values cutoffs
    returns [xsize, ysize]
    """
    scale, sizes = sizes_and_scale_minp(smallest_p)
    for i in range(len(sizes)):
        if p <= float(sizes[i]):
            return [xsize * scale[i], ysize * scale[i]]
    return [xsize * 0.15, ysize * 0.15]

def correlation_plot(ycoords, xcoords, xprottoloc, yprottoloc, xsample, ysample,
                     xbreaks, ybreaks, recip, densityplot):
    """
    correlation plot makes a plot of the Fisher's exact test for each chromosome
    """
    from scipy import stats
    import pandas as pd
    import seaborn as sns; sns.set()
    import matplotlib
    import matplotlib.pyplot as plt
    import matplotlib.ticker as ticker
    from matplotlib.ticker import StrMethodFormatter, NullFormatter
    import numpy as np
    # set seaborn stuff
    #sns.set(rc={'text.usetex' : True})
    sns.set_style("ticks", {'font.family': ['sans-serif'],
                                'font.sans-serif': ['Helvetica'],
                                'grid.color': '.95'})
    # Preserve the vertical order of embedded images:
    matplotlib.rcParams['image.composite_image'] = False
    # text as font in pdf
    matplotlib.rcParams['pdf.fonttype'] = 42
    matplotlib.rcParams['ps.fonttype'] = 42

    # parse the xbreaks and the ybreaks.
    # These are where there are low-opacity,
    #  dotted lines to show breaks in synteny
    # example entries are like this:
      #"CM022887.1_chromosome_2:4392062"
      #"CM022887.1_chromosome_2:8784125"

    xbreaks_list = []
    for thisx in xbreaks:
        scaf = thisx.split(":")[0]
        pos  = int(thisx.split(":")[1])
        xbreaks_list.append([scaf, pos])
    ybreaks_list = []
    for thisy in ybreaks:
        scaf = thisy.split(":")[0]
        pos  = int(thisy.split(":")[1])
        ybreaks_list.append([scaf, pos])

    # first make a lookup table of how to calculate the
    #  x and y coords. This lookup is just the amount of
    # bp to add to the value when plotting. We pass the xprot_to_loc,
    #  xprot_to_scaf in case we need to sort everything based on order of
    #  occurrence on the scaffolds
    x_offset, vertical_lines_at, xmax, xbreaks, xticklabel, xtickpos, xorder = parse_coords(
        xcoords, xsample, "x")
    print("found {} x chromosomes".format(len(x_offset)))
    x_genome_coords = pd.read_csv(xcoords, header = None, sep = " ")
    x_genome_coords.columns = ["scaf", "scaflen", "cumsum"]
    print(x_offset)

    y_offset, horizontal_lines_at, ymax, ybreaks, yticklabel, ytickpos, yorder = parse_coords(
        ycoords, ysample, "y",
        xprottoloc, yprottoloc, recip, xticklabel)
    print("found {} y chromosomes".format(len(y_offset)))
    y_genome_coords = pd.read_csv(ycoords, header = None, sep = " ")
    y_genome_coords.columns = ["scaf", "scaflen", "cumsum"]

    # this section will be used when performing this test over smaller bins
    ## get the max plotting length of each genome
    #xplotlen = x_offset[xorder[-1]]
    #yplotlen = y_offset[yorder[-1]]
    ## now get the size divided by 200
    #xbinsize = int(int(xplotlen/100/100)*100)
    #ybinsize = int(int(yplotlen/100/100)*100)

    # now make a dict of intervals for x and y
    # now make a lookup table of where the prots are.
    #  Use the x_offset and y_offset to recalculate where the plotting
    xstruct = generate_coord_structs(xprottoloc)
    xstruct["prot_plot_middle"] = {}
    ystruct = generate_coord_structs(yprottoloc)
    ystruct["prot_plot_middle"] = {}
    # get rid of proteins that we don't need along the x axis
    #  also set the plotting position based on the offset
    for prot in list(xstruct["prot_to_middle"].keys()):
        scaf = xstruct["prot_to_scaf"][prot]
        if scaf not in x_offset:
            for thisdict in xstruct:
                xstruct[thisdict].pop(prot, None)
        else:
            xstruct["prot_plot_middle"][prot] = xstruct["prot_to_middle"][prot] + x_offset[scaf]
    # get rid of proteins that we don't need along the y axis
    #  also set the plotting position based on the offset
    for prot in list(ystruct["prot_to_middle"].keys()):
        scaf = ystruct["prot_to_scaf"][prot]
        if scaf not in y_offset:
            for thisdict in xstruct:
                ystruct[thisdict].pop(prot, None)
        else:
            ystruct["prot_plot_middle"][prot] = ystruct["prot_to_middle"][prot] + y_offset[scaf]

    # now open the blast results and translate the pairs
    #  into plotting positions
    df = pd.read_csv(recip, header=None, sep = "\t")
    df.columns = ["xgene", "ygene", "pident", "length",
                  "mismatch", "gapopen", "qstart", "qend",
                  "sstart", "send", "evalue", "bitscore"]
    df = df[["xgene", "ygene", "bitscore", "evalue"]]
    #print(x_prot_to_loc)
    df["xpos"] = df["xgene"].map(xstruct["prot_plot_middle"])
    df["ypos"] = df["ygene"].map(ystruct["prot_plot_middle"])

    # I don't remember why the x and y is switched here.
    df["yscaf"] = df["ygene"].map(ystruct["prot_to_scaf"])
    df["xscaf"] = df["xgene"].map(xstruct["prot_to_scaf"])
    #df = df.dropna() # this messed up plotting order if there were no hits on that scaf.

    df = df.sort_values(by=['xpos'])
    df = df.dropna()
    df.reset_index(drop=True, inplace = True)
    print(df)

    fisher_dict = []
    for xscaf in xorder: #Li
        for yscaf in yorder: #Wi
            #calculate the cells for fisher exact
            query = "yscaf == '{}' & xscaf == '{}'".format(yscaf, xscaf)
            inX_inY   = len(df.query(query))
            query = "yscaf == '{}' & xscaf != '{}'".format(yscaf, xscaf)
            inX_outY  = len(df.query(query))
            query = "yscaf != '{}' & xscaf == '{}'".format(yscaf, xscaf)
            outX_inY  = len(df.query(query))
            query = "yscaf != '{}' & xscaf != '{}'".format(yscaf, xscaf)
            outX_outY = len(df.query(query))
            table = [[inX_inY, outX_inY], [inX_outY, outX_outY]]
            oddsratio, pvalue = stats.fisher_exact(table, alternative="greater")
            fisher_dict.append({"xscaf": xscaf, "yscaf": yscaf,
                                "inX_inY": inX_inY, "inX_outY": inX_outY,
                                "outX_inY": outX_inY, "outX_outY": outX_outY,
                                "oddsratio": oddsratio, "pvalue": pvalue,
                                "x_plot_pos": xtickpos[xticklabel.index(xscaf)],
                                "y_plot_pos": ytickpos[yticklabel.index(yscaf)]})
    fisherdf = pd.DataFrame(fisher_dict)
    # figure out the widths of the cells to find the optimal dot size
    widths = []
    #for this_list in [horizontal_lines_at, vertical_lines_at
    for this_list in [list(sorted(x_offset.values()))]:
        for i in range(len(this_list)-1):
            widths.append(this_list[i+1]-this_list[i])
    x_median_size = statistics.median(sorted(widths))
    x_median_size = np.percentile(sorted(widths), 85)
    max_x = max(x_offset.values())
    max_y = max(y_offset.values())
    y_median_size = (x_median_size/max_x)*max_y

    # now make a scatter plot
    figWidth = 8
    figHeight = 8
    plt.figure(figsize=(figWidth,figHeight))
    #set the panel dimensions
    panelWidth = 4
    panelHeight = 4
    dpanel_width = 0.25
    #find the margins to center the panel in figure
    leftMargin = (figWidth - panelWidth)/2
    bottomMargin = ((figHeight - panelHeight)/2)
    panel1 = plt.axes([leftMargin/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         panelWidth/figWidth,   #width
                         panelHeight/figHeight])     #height
    panel1.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=True,
                        left=False, labelleft=True,
                        right=False, labelright=False,
                        top=False, labeltop=False)
    panelleg = plt.axes([(leftMargin+panelWidth + 0.1)/figWidth, #left
                         bottomMargin/figHeight,    #bottom
                         (dpanel_width*4)/figWidth,   #width
                         panelHeight/figHeight])     #height
    panelleg.tick_params(axis='both',which='both',
                        bottom=False, labelbottom=False,
                        left=False, labelleft=False,
                        right=False, labelright=False,
                        top=False, labeltop=False)

    # plot the circles for the significance
    smallest_p = min(fisherdf["pvalue"])
    for index, row in fisherdf.iterrows():
        x, y = quantize_pvalue(x_median_size/2,
                              y_median_size/2,
                              float(row["pvalue"]),
                              smallest_p)
        circ = matplotlib.patches.Ellipse(
                   (row["x_plot_pos"], row["y_plot_pos"]),
                   x, y, ec = None, lw = None, color="gray")
        panel1.add_patch(circ)


    # set the panel linewidth thinner
    for this_panel in [panel1]:
        for axis in ['top','bottom','left','right']:
            this_panel.spines[axis].set_linewidth(0.5)

    # remove spines on legend
    for this_panel in [panelleg]:
        for axis in ['top','bottom','left','right']:
            this_panel.spines[axis].set_visible(False)

    # set mins and max
    panel1.set_xlim([0,xmax])
    panel1.set_ylim([0,ymax])
    xscalar = (dpanel_width*4)/panelWidth
    panelleg.set_xlim([0,xmax*xscalar]) # percent
    panelleg.set_ylim([0,ymax])

    # now plot the legend
    # there are 6 sizes to plot
    # take up the top 1/3 of the panel
    legend_bottom_y = ymax - int(ymax/3)
    legend_top_y    = ymax
    leg_y_seglen        = int(ymax/3/7)
    # set the points 15% away from left edge
    leg_x_offset        = 0.15 * (xmax*xscalar)
    leg_x_pos_ellipse = [leg_x_offset]*6
    leg_y_pos_ellipse = [legend_top_y - leg_y_seglen]
    for i in range(6):
        leg_y_pos_ellipse.append(leg_y_pos_ellipse[-1] - leg_y_seglen)
    # now actually plot the ellipses
    legscale, legsize = sizes_and_scale_minp(smallest_p)
    legscale.append(0.15)
    legsize.append("1")
    for i in range(6):
        x, y = quantize_pvalue(x_median_size/2,
                              y_median_size/2,
                              float(legsize[i]),
                              min([float(x) for x in legsize]))
        circ = matplotlib.patches.Ellipse(
                   (leg_x_pos_ellipse[i], leg_y_pos_ellipse[i]),
                   x, y, ec = None, lw = None, color="gray")
        panelleg.add_patch(circ)
        textx = leg_x_pos_ellipse[i] + leg_x_offset
        texty = leg_y_pos_ellipse[i]
        s = "p <= {}".format(legsize[i])
        matplotlib.pyplot.text(textx, texty, s, ha="left", fontsize = 8)

    # set x ticks
    panel1.set_xticks(xtickpos)
    panel1.set_xticklabels(xticklabel, fontsize=8, rotation = 90)
    panel1.set_xlabel(xsample + " scaffolds")

    # set y ticks
    panel1.set_yticks(ytickpos)
    panel1.set_yticklabels(yticklabel, fontsize=8)
    panel1.set_ylabel(ysample + " scaffolds")

    for this_axis in [panel1]:
        this_axis.xaxis.get_offset_text().set_visible(False)
        this_axis.yaxis.get_offset_text().set_visible(False)

    #plot vertical lines
    for value in vertical_lines_at:
        panel1.axvline(x=value, color="black", lw=0.5)
    #plot horizontal lines
    for value in horizontal_lines_at:
        panel1.axhline(y=value, color="black", lw=0.5)

    # plot vertical BOS
    for value in xbreaks:
        panel1.axvline(x=value, color=[0,0,0,0.25], lw=0.5, linestyle="dotted")
    # plot horizontal BOS
    for value in ybreaks:
        panel1.axhline(y=value, color=[0,0,0,0.25], lw=0.5, linestyle="dotted")
    plt.savefig(densityplot)


"""
This handles the correlation matrices
"""
rule plot_fishers:
    input:
        ycoords = "synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
        xcoords = "synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
        xprottoloc = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["prot_to_loc"],
        yprottoloc = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["prot_to_loc"],
        recip = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp"
    output:
        density = "synteny_analysis/plots/significance/wholechr/{xsample}_and_{ysample}_fisher.pdf",
    threads:
        1
    params:
        xsample = lambda wildcards: wildcards.xsample,
        ysample = lambda wildcards: wildcards.ysample,
        xbreaks  = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["breaks"],
        ybreaks  = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["breaks"],
        keep_x   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["xaxisspecies"][wildcards.xsample]) or ("noxlines" in config["xaxisspecies"][wildcards.xsample])) else True,
        keep_y   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["yaxisspecies"][wildcards.ysample]) or ("noylines" in config["yaxisspecies"][wildcards.ysample])) else True
    run:
        correlation_plot(input.ycoords, input.xcoords,
                     input.xprottoloc, input.yprottoloc,
                     params.xsample, params.ysample,
                     params.xbreaks, params.ybreaks,
                     input.recip, output.density)

rule xprot_to_color:
    """
    In addition to plotting the synteny without a color scheme,
      we also would like to plot by coloring with another species' color scheme
    The output is just:
    xsample_prot\thex_color
    """
    input:
        x_prot_to_loc = lambda wildcards: config["xaxisspecies"][wildcards.colorby]["prot_to_loc"]
    output:
        prot_to_color = "synteny_analysis/prot_to_color/{colorby}_prottocolor.tsv"
    params:
        colormap = lambda wildcards: config["xaxisspecies"][wildcards.colorby]["chrom_to_color"]
    run:
        print(params.colormap)
        # parse the printing information
        print_list = []
        for key in params.colormap:
            coord = key
            color = params.colormap[coord]
            scaf = coord.split(":")[0]
            pos_raw = coord.split(":")[1]
            if pos_raw == "all":
                pos_min = 1
                pos_max = 999999999
            else:
                pos_min = int(pos_raw.split("-")[0])
                pos_max = int(pos_raw.split("-")[1])
            print_list.append({"scaf": scaf, "pos_min": pos_min,
                               "pos_max": pos_max, "color": color})
        df = pd.DataFrame.from_dict(print_list)
        print(df)
        #df["colors_py"] =  df["color"].apply(matplotlib.colors.to_rgba)
        out_handle = open(output.prot_to_color, "w")
        xstruct = generate_coord_structs(input.x_prot_to_loc)
        for prot in list(xstruct["prot_to_scaf"].keys()):
            scaf = xstruct["prot_to_scaf"][prot]
            if scaf in list(df["scaf"]):
                pos  = xstruct["prot_to_middle"][prot]
                query = "scaf == '{}' & pos_min <= {} & pos_max >= {}".format(scaf, pos, pos)
                color = df.query(query)["color"].values[0]
                print("{}\t{}".format(prot, color), file=out_handle)
            else:
                color = "#000000"
                print("{}\t{}".format(prot, color), file=out_handle)
        out_handle.close()

"""
This makes the plots where the proteins are colored by another protein set.

Jan 12 2021 I am not sure what the no missing plot version is.

For some reason I am getting an InputFunctionException
"""
rule plot_synteny_x_colored_by_x:
    input:
        ycoords = "synteny_analysis/genome_coords/y_genome_coords/{ysample}_genomecoords.txt",
        xcoords = "synteny_analysis/genome_coords/x_genome_coords/{xsample}_genomecoords.txt",
        xprottoloc = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["prot_to_loc"],
        yprottoloc = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["prot_to_loc"],
        recip = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{ysample}_recip.blastp",
        color_by_blast = "synteny_analysis/blastp_results/reciprocal_best/{xsample}_and_{colorby}_recip.blastp",
        color_by = "synteny_analysis/prot_to_color/{colorby}_prottocolor.tsv"
    output:
        synplot = "synteny_analysis/plots/synteny_colored_by/{xsample}_and_{ysample}_coloredby_{colorby}_synteny.pdf",
        nodots = "synteny_analysis/plots/synteny_colored_by_no_missing/{xsample}_and_{ysample}_coloredby_{colorby}_synteny.pdf",
        plot_order = "synteny_analysis/plot_order/colored_by/{xsample}_and_{ysample}_coloredby_{colorby}_plotorder.tsv"
    threads:
        1
    params:
        xsample = lambda wildcards: wildcards.xsample,
        ysample = lambda wildcards: wildcards.ysample,
        color_sample = lambda wildcards: wildcards.colorby,
        xbreaks  = lambda wildcards: config["xaxisspecies"][wildcards.xsample]["breaks"],
        ybreaks  = lambda wildcards: config["yaxisspecies"][wildcards.ysample]["breaks"],
        keep_x   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["xaxisspecies"][wildcards.xsample]) or ("noxlines" in config["xaxisspecies"][wildcards.xsample])) else True,
        keep_y   = lambda wildcards: False if ( ("sort_by_x_coord_blast" in config["yaxisspecies"][wildcards.ysample]) or ("noylines" in config["yaxisspecies"][wildcards.ysample])) else True,
        autoxb   = lambda wildcards: True if ( ("auto_d_breaks" in config["xaxisspecies"][wildcards.xsample]) and (config["xaxisspecies"][wildcards.xsample]["auto_d_breaks"] == True)) else False,
        autoyb   = lambda wildcards: True if ( ("auto_d_breaks" in config["yaxisspecies"][wildcards.ysample]) and (config["yaxisspecies"][wildcards.ysample]["auto_d_breaks"] == True)) else False,
    run:
        print("printing x")
        print(config["xaxisspecies"][wildcards.xsample])
        #first figure out what the color should be for each protein pair
        colorby_prot_to_color = {}
        with open(input.color_by, "r") as f:
            for line in f:
                line = line.strip()
                if line:
                    splitd = line.split("\t")
                    xprot = splitd[0]
                    colorbyprot = splitd[1]
                    colorby_prot_to_color[xprot] = colorbyprot
        # now use the blast results to lookup the prot color
        if params.xsample == params.color_sample:
            print("x is the same as color")
            prot_to_color = colorby_prot_to_color
        else:
            prot_to_color = {}
            try_counter =0
            fail_counter = 0
            with open(input.color_by_blast, "r") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        splitd = line.split("\t")
                        try:
                            prot_to_color[splitd[0]] = colorby_prot_to_color[splitd[1]]
                            try_counter += 1
                        except:
                            prot_to_color[splitd[0]] = "#000000"
                            fail_counter += 1
            print(try_counter, fail_counter)
        # now that we have the colors, plot
        synteny_plot(input.ycoords, input.xcoords,
                     input.xprottoloc, input.yprottoloc,
                     params.xsample, params.ysample,
                     params.xbreaks, params.ybreaks,
                     input.recip, output.synplot, None,
                     output.plot_order, prot_to_color,
                     False,
                     plot_x_lines = params.keep_x,
                     plot_y_lines = params.keep_y,
                     auto_determine_x_breaks = params.autoxb,
                     auto_determine_y_breaks = params.autoyb)

        # plot again, but without the black (missing) points
        synteny_plot(input.ycoords, input.xcoords,
                     input.xprottoloc, input.yprottoloc,
                     params.xsample, params.ysample,
                     params.xbreaks, params.ybreaks,
                     input.recip, output.nodots, None,
                     output.plot_order, prot_to_color,
                     True,
                     plot_x_lines = params.keep_x,
                     plot_y_lines = params.keep_y,
                     auto_determine_x_breaks = params.autoxb,
                     auto_determine_y_breaks = params.autoyb)
